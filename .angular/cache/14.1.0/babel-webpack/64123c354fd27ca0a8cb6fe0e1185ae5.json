{"ast":null,"code":"import _classCallCheck from \"C:/Users/Mon2/OneDrive/Desktop/angular-gojs/gojs-angular-basic/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Mon2/OneDrive/Desktop/angular-gojs/gojs-angular-basic/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { EventEmitter, Component, NgZone, Input, Output, ViewChild, Injectable, NgModule } from '@angular/core';\nimport * as go from 'gojs';\nimport produce from 'immer';\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/ng-diagram-helper.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * An interface to allow methods defined below to accept Palette or Diagram Components,\r\n * without requiring DiagramComponent or PaletteComponent directly in this file\r\n * (that would create a circular dependency)\r\n * @record\r\n */\n\nimport * as Éµngcc0 from '@angular/core';\nvar _c0 = [\"ngDiagram\"];\nvar _c1 = [\"ngPalette\"];\nvar _c2 = [\"ngOverview\"];\n\nfunction IDiagramOrPaletteComponent() {}\n\nif (false) {\n  /** @type {?} */\n  IDiagramOrPaletteComponent.prototype.modelChange;\n  /** @type {?} */\n\n  IDiagramOrPaletteComponent.prototype.zone;\n  /** @type {?} */\n\n  IDiagramOrPaletteComponent.prototype.nodeDataArray;\n  /** @type {?} */\n\n  IDiagramOrPaletteComponent.prototype.linkDataArray;\n  /** @type {?} */\n\n  IDiagramOrPaletteComponent.prototype.modelData;\n}\n/**\r\n * Defines some shared helper static functions, used in Diagram / Palette / Overview Components\r\n */\n\n\nvar NgDiagramHelper = /*#__PURE__*/function () {\n  function NgDiagramHelper() {\n    _classCallCheck(this, NgDiagramHelper);\n  }\n  /**\r\n   * Ensures mousemove event listeners on a diagram's canvas are run outside NgZone.\r\n   * This way, change detection isn't triggered on each mousemove, improving performance.\r\n   *\r\n   * If some state-alteration must happen on a mousemove event inside the diagram, use zone.run() to make sure the event triggers angular change detection.\r\n   * Used by DiagramComponent, PaletteComponent, and OverviewComponent in their ngAfterViewInit lifecycle hooks\r\n   * @param {?} diagram\r\n   * @param {?} zone\r\n   * @return {?}\r\n   */\n\n\n  _createClass(NgDiagramHelper, null, [{\n    key: \"makeMouseMoveRunOutsideAngularZone\",\n    value: function makeMouseMoveRunOutsideAngularZone(diagram, zone) {\n      var _this = this;\n\n      diagram.addEventListener =\n      /**\r\n      * @param {?} DOMElement\r\n      * @param {?} name\r\n      * @param {?} listener\r\n      * @param {?} capture\r\n      * @return {?}\r\n      */\n      function (DOMElement, name, listener, capture) {\n        /** @type {?} */\n        var superAddEventListener = go.Diagram.prototype.addEventListener;\n\n        if (name === 'mousemove') {\n          zone.runOutsideAngular(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            return superAddEventListener.call(_this, DOMElement, name, listener, capture);\n          });\n        } else {\n          zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            superAddEventListener.call(_this, DOMElement, name, listener, capture);\n          });\n        }\n      };\n    }\n    /**\r\n     * Initialize a given diagram's model with given node / link / model data\r\n     * @param {?} diagram\r\n     * @param {?} nodeDataArray\r\n     * @param {?} linkDataArray\r\n     * @param {?} modelData\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"initializeModel\",\n    value: function initializeModel(diagram, nodeDataArray, linkDataArray, modelData) {\n      diagram.delayInitialization(\n      /**\r\n      * @return {?}\r\n      */\n      function () {\n        /** @type {?} */\n        var model = diagram.model;\n        model.commit(\n        /**\r\n        * @param {?} m\r\n        * @return {?}\r\n        */\n        function (m) {\n          if (modelData) {\n            m.assignAllDataProperties(m.modelData, modelData);\n          }\n\n          m.mergeNodeDataArray(m.cloneDeep(nodeDataArray));\n\n          if (linkDataArray && m instanceof go.GraphLinksModel) {\n            m.mergeLinkDataArray(m.cloneDeep(linkDataArray));\n          }\n        }, null);\n      });\n    }\n    /**\r\n     * Initialize the model changed listener for the Palette / Diagram of a given compoennt; ensure it runs inside the component's ngZone.\r\n     * Those changes will be emitted through a the component's modelChange EventEmitter.\r\n     * @param {?} component\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"initializeModelChangedListener\",\n    value: function initializeModelChangedListener(component) {\n      /** @type {?} */\n      var diagram = null;\n      if (!component.hasOwnProperty(\"diagram\") && !component.hasOwnProperty(\"palette\")) return;\n      if (component.hasOwnProperty(\"diagram\")) diagram = component[\"diagram\"];\n      if (component.hasOwnProperty(\"palette\")) diagram = component[\"palette\"];\n\n      component.modelChangedListener =\n      /**\r\n      * @param {?} e\r\n      * @return {?}\r\n      */\n      function (e) {\n        if (e.isTransactionFinished && e.model && !e.model.isReadOnly && component.modelChange) {\n          // this must be done within a NgZone.run block, so changes are detected in the parent component\n          component.zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            /** @type {?} */\n            var dataChanges =\n            /** @type {?} */\n            e.model.toIncrementalData(e);\n            if (dataChanges !== null) component.modelChange.emit(dataChanges);\n          });\n        }\n      };\n\n      diagram.addModelChangedListener(component.modelChangedListener);\n    }\n    /**\r\n     * Merge the app-level node / link / model data of a supplied Diagram|Palette Component with its underlying Diagram|Palette model data\r\n     * @param {?} component\r\n     * @param {?=} isInit Whether or not to treat this update as a Diagram initialization\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"mergeAppDataWithModel\",\n    value: function mergeAppDataWithModel(component, isInit) {\n      /** @type {?} */\n      var diagram = null;\n      if (component.hasOwnProperty(\"diagram\")) diagram = component[\"diagram\"];\n      if (component.hasOwnProperty(\"palette\")) diagram = component[\"palette\"];\n      diagram.model.commit(\n      /**\r\n      * @param {?} m\r\n      * @return {?}\r\n      */\n      function (m) {\n        if (isInit) diagram.model.modelData = {}; // update modelData first, in case bindings on nodes / links depend on model data\n\n        diagram.model.assignAllDataProperties(diagram.model.modelData, component.modelData); // merge node / link data\n\n        if (isInit) diagram.model.nodeDataArray = [];\n        diagram.model.mergeNodeDataArray(component.nodeDataArray);\n\n        if (component.linkDataArray && diagram.model instanceof go.GraphLinksModel) {\n          if (isInit) diagram.model.linkDataArray = [];\n          diagram.model.mergeLinkDataArray(component.linkDataArray);\n        }\n      }, isInit ? null : 'update data');\n    }\n  }]);\n\n  return NgDiagramHelper;\n}();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/diagram.component.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar DiagramComponent = /*#__PURE__*/(function () {\n  var DiagramComponent = /*#__PURE__*/function () {\n    /**\r\n     * @param {?} zone\r\n     */\n    function DiagramComponent(zone) {\n      _classCallCheck(this, DiagramComponent);\n\n      this.zone = zone;\n      /**\r\n       * Link data for diagram. Optional.\r\n       */\n\n      this.linkDataArray = null;\n      /**\r\n       * Model data for diagram. Optional.\r\n       */\n\n      this.modelData = null;\n      /**\r\n       * Model changed listener function for diagram\r\n       */\n\n      this.modelChangedListener = null;\n      /**\r\n       * Whether or not to skip merging app data with GoJS model data (set to true if update is coming from GoJS, false if coming from app-level, usually)\r\n       */\n\n      this.skipsDiagramUpdate = false;\n      /**\r\n       * Event emitter -- fires when diagram model changes. Capture this emitted event in parent component\r\n       */\n\n      this.modelChange = new EventEmitter();\n      /**\r\n       * The Diagram itself\r\n       */\n\n      this.diagram = null;\n      /**\r\n       * An internal flag used to tell ngOnChanges to treat the next sync operation as a Diagram initialization\r\n       */\n\n      this.wasCleared = false;\n    }\n    /**\r\n     * Initializes diagram / model after view init\r\n     * @return {?}\r\n     */\n\n\n    _createClass(DiagramComponent, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        if (!this.diagramDiv) {\n          throw new Error(\"diagramDiv is not defined\");\n        }\n\n        this.diagram = this.initDiagram();\n\n        if (!(this.diagram instanceof go.Diagram)) {\n          throw new Error(\"initDiagram function did not return a go.Diagram\");\n        } // reduces change detection on mouse moves, boosting performance\n\n\n        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.diagram, this.zone); // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,\n        // using the overridden addEventListener function defined in makeMouseMoveRunOutsideAngularZone\n\n        /** @type {?} */\n\n        var divRef = this.diagramDiv.nativeElement;\n        if (divRef === null) return;\n        this.diagram.div = divRef; // initialize the diagram model with the provided node / link / model data\n\n        NgDiagramHelper.initializeModel(this.diagram, this.nodeDataArray, this.linkDataArray, this.modelData); // initializer model listener\n\n        NgDiagramHelper.initializeModelChangedListener(this);\n      } // end ngAfterViewInit\n      // end ngAfterViewInit\n\n      /**\r\n       * If a change has occurred on an \\@Input property, merge the app-level changes with GoJS\r\n       * @return {?}\r\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        var _this2 = this;\n\n        if (!this.diagram || !this.diagram.model || this.skipsDiagramUpdate) return; // if clear was just called, treat this as initial\n\n        if (this.wasCleared) {\n          this.diagram.delayInitialization(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            NgDiagramHelper.mergeAppDataWithModel(_this2, true);\n          });\n          this.wasCleared = false;\n        } else {\n          NgDiagramHelper.mergeAppDataWithModel(this);\n        }\n      } // end ngOnChanges\n      // end ngOnChanges\n\n      /**\r\n       * Clears the diagram of all nodes, links, and model data.\r\n       * Also clears the UndoManager history and clipboard.\r\n       * The next state update will be treated as diagram initialization.\r\n       * @return {?}\r\n       */\n\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        /** @type {?} */\n        var diagram = this.diagram;\n\n        if (diagram !== null) {\n          diagram.clear();\n          this.wasCleared = true;\n        }\n      } // end clear function\n      // end clear function\n\n      /**\r\n       * Set this.diagram.div to null, removing all event listeners\r\n       * @return {?}\r\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.diagram.div = null; // removes event listeners\n      } // end ngOnDestroy function\n\n    }]);\n\n    return DiagramComponent;\n  }();\n\n  DiagramComponent.Éµfac = function DiagramComponent_Factory(t) {\n    return new (t || DiagramComponent)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.NgZone));\n  };\n\n  DiagramComponent.Éµcmp = /*@__PURE__*/Éµngcc0.ÉµÉµdefineComponent({\n    type: DiagramComponent,\n    selectors: [[\"gojs-diagram\"]],\n    viewQuery: function DiagramComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        Éµngcc0.ÉµÉµqueryRefresh(_t = Éµngcc0.ÉµÉµloadQuery()) && (ctx.diagramDiv = _t.first);\n      }\n    },\n    inputs: {\n      linkDataArray: \"linkDataArray\",\n      modelData: \"modelData\",\n      skipsDiagramUpdate: \"skipsDiagramUpdate\",\n      initDiagram: \"initDiagram\",\n      nodeDataArray: \"nodeDataArray\",\n      divClassName: \"divClassName\"\n    },\n    outputs: {\n      modelChange: \"modelChange\"\n    },\n    features: [Éµngcc0.ÉµÉµNgOnChangesFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"className\"], [\"ngDiagram\", \"\"]],\n    template: function DiagramComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµelement(0, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        Éµngcc0.ÉµÉµproperty(\"className\", ctx.divClassName);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return DiagramComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * Diagram initialization function. Returns a go.Diagram.\r\n   * Do not initialize model data in this function.\r\n   * @type {?}\r\n   */\n  DiagramComponent.prototype.initDiagram;\n  /**\r\n   * Node data for diagram\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.nodeDataArray;\n  /**\r\n   * Link data for diagram. Optional.\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.linkDataArray;\n  /**\r\n   * Model data for diagram. Optional.\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.modelData;\n  /**\r\n   * Diagram div class name. Use this name to style your diagram in CSS.\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.divClassName;\n  /**\r\n   * Model changed listener function for diagram\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.modelChangedListener;\n  /**\r\n   * Whether or not to skip merging app data with GoJS model data (set to true if update is coming from GoJS, false if coming from app-level, usually)\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.skipsDiagramUpdate;\n  /**\r\n   * Event emitter -- fires when diagram model changes. Capture this emitted event in parent component\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.modelChange;\n  /**\r\n   * The DIV element holding the Diagram\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.diagramDiv;\n  /**\r\n   * The Diagram itself\r\n   * @type {?}\r\n   */\n\n  DiagramComponent.prototype.diagram;\n  /**\r\n   * An internal flag used to tell ngOnChanges to treat the next sync operation as a Diagram initialization\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  DiagramComponent.prototype.wasCleared;\n  /** @type {?} */\n\n  DiagramComponent.prototype.zone;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/palette.component.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar PaletteComponent = /*#__PURE__*/(function () {\n  var PaletteComponent = /*#__PURE__*/function () {\n    /**\r\n     * @param {?} zone\r\n     */\n    function PaletteComponent(zone) {\n      _classCallCheck(this, PaletteComponent);\n\n      this.zone = zone;\n      /**\r\n       * Link data for palette. Optional.\r\n       */\n\n      this.linkDataArray = null;\n      /**\r\n       * Model data for palette. Optional.\r\n       */\n\n      this.modelData = null;\n      /**\r\n       * Event emitter -- fires when palette model changes. Capture this emitted event in parent component\r\n       */\n\n      this.modelChange = new EventEmitter();\n      /**\r\n       * The Palette itself\r\n       */\n\n      this.palette = null;\n    }\n    /**\r\n     * Initialize Palette after view init\r\n     * @return {?}\r\n     */\n\n\n    _createClass(PaletteComponent, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        if (!this.paletteDiv) {\n          throw new Error(\"paletteDiv is not defined\");\n        }\n\n        this.palette = this.initPalette();\n\n        if (!(this.palette instanceof go.Palette)) {\n          throw new Error(\"initPalette function did not return a go.Palette\");\n        } // reduces change detection on mouse moves, boosting performance\n\n\n        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.palette, this.zone); // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,\n        // using the overridden addEventListener function above\n\n        /** @type {?} */\n\n        var divRef = this.paletteDiv.nativeElement;\n        if (divRef == null) return;\n        this.palette.div = divRef; // initialize palette model\n\n        NgDiagramHelper.initializeModel(this.palette, this.nodeDataArray, this.linkDataArray, this.modelData);\n      }\n      /**\r\n       * If a change has occured on an \\@Input property, merge the app-level changes with GoJS\r\n       * @return {?}\r\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        if (!this.palette || !this.palette.model) return;\n        NgDiagramHelper.mergeAppDataWithModel(this);\n      } // end ngOnChanges \n      // end ngOnChanges \n\n      /**\r\n       * @return {?}\r\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.palette.div = null; // removes event listeners\n      }\n    }]);\n\n    return PaletteComponent;\n  }();\n\n  PaletteComponent.Éµfac = function PaletteComponent_Factory(t) {\n    return new (t || PaletteComponent)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.NgZone));\n  };\n\n  PaletteComponent.Éµcmp = /*@__PURE__*/Éµngcc0.ÉµÉµdefineComponent({\n    type: PaletteComponent,\n    selectors: [[\"gojs-palette\"]],\n    viewQuery: function PaletteComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        Éµngcc0.ÉµÉµqueryRefresh(_t = Éµngcc0.ÉµÉµloadQuery()) && (ctx.paletteDiv = _t.first);\n      }\n    },\n    inputs: {\n      linkDataArray: \"linkDataArray\",\n      modelData: \"modelData\",\n      initPalette: \"initPalette\",\n      nodeDataArray: \"nodeDataArray\",\n      divClassName: \"divClassName\"\n    },\n    outputs: {\n      modelChange: \"modelChange\"\n    },\n    features: [Éµngcc0.ÉµÉµNgOnChangesFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"className\"], [\"ngPalette\", \"\"]],\n    template: function PaletteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµelement(0, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        Éµngcc0.ÉµÉµproperty(\"className\", ctx.divClassName);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return PaletteComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * Palette initialization function. Returns a go.Palette.\r\n   * Do not initialize model data in this function.\r\n   * @type {?}\r\n   */\n  PaletteComponent.prototype.initPalette;\n  /**\r\n   * Node data for palette\r\n   * @type {?}\r\n   */\n\n  PaletteComponent.prototype.nodeDataArray;\n  /**\r\n   * Link data for palette. Optional.\r\n   * @type {?}\r\n   */\n\n  PaletteComponent.prototype.linkDataArray;\n  /**\r\n   * Model data for palette. Optional.\r\n   * @type {?}\r\n   */\n\n  PaletteComponent.prototype.modelData;\n  /**\r\n   * Palette div class name. Use this name to style your palette in CSS\r\n   * @type {?}\r\n   */\n\n  PaletteComponent.prototype.divClassName;\n  /**\r\n   * Event emitter -- fires when palette model changes. Capture this emitted event in parent component\r\n   * @type {?}\r\n   */\n\n  PaletteComponent.prototype.modelChange;\n  /**\r\n   * The DIV element holding the Palette\r\n   * @type {?}\r\n   */\n\n  PaletteComponent.prototype.paletteDiv;\n  /**\r\n   * The Palette itself\r\n   * @type {?}\r\n   */\n\n  PaletteComponent.prototype.palette;\n  /** @type {?} */\n\n  PaletteComponent.prototype.zone;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/overview.component.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar OverviewComponent = /*#__PURE__*/(function () {\n  var OverviewComponent = /*#__PURE__*/function () {\n    /**\r\n     * @param {?} zone\r\n     */\n    function OverviewComponent(zone) {\n      _classCallCheck(this, OverviewComponent);\n\n      this.zone = zone;\n      /**\r\n       * The Diagram to observe with the Overview\r\n       */\n\n      this.observedDiagram = null;\n      /**\r\n       * The Overview itself\r\n       */\n\n      this.overview = null;\n    }\n    /**\r\n     * Initialize the overview\r\n     * @return {?}\r\n     */\n\n\n    _createClass(OverviewComponent, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        if (!this.overviewDiv) {\n          throw new Error(\"overviewDiv is not defined\");\n        }\n\n        if (this.initOverview) {\n          this.overview = this.initOverview();\n\n          if (!(this.overview instanceof go.Overview)) {\n            throw new Error(\"initOverview function did not return a go.Overview\");\n          }\n        } else {\n          this.overview = new go.Overview();\n          this.overview.contentAlignment = go.Spot.Center;\n        } // reduces change detection on mouse moves, boosting performance\n\n\n        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.overview, this.zone);\n        this.overview.div = this.overviewDiv.nativeElement;\n      }\n      /**\r\n       * Only update when the observed diagram changes\r\n       * @param {?} changes\r\n       * @return {?}\r\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (!this.overview) return;\n\n        if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {\n          this.overview.observed = changes.observedDiagram.currentValue;\n        }\n      }\n      /**\r\n       * @return {?}\r\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.overview.div = null; // removes event listeners\n      }\n    }]);\n\n    return OverviewComponent;\n  }();\n\n  OverviewComponent.Éµfac = function OverviewComponent_Factory(t) {\n    return new (t || OverviewComponent)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.NgZone));\n  };\n\n  OverviewComponent.Éµcmp = /*@__PURE__*/Éµngcc0.ÉµÉµdefineComponent({\n    type: OverviewComponent,\n    selectors: [[\"gojs-overview\"]],\n    viewQuery: function OverviewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµviewQuery(_c2, 7);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        Éµngcc0.ÉµÉµqueryRefresh(_t = Éµngcc0.ÉµÉµloadQuery()) && (ctx.overviewDiv = _t.first);\n      }\n    },\n    inputs: {\n      observedDiagram: \"observedDiagram\",\n      initOverview: \"initOverview\",\n      divClassName: \"divClassName\"\n    },\n    features: [Éµngcc0.ÉµÉµNgOnChangesFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"className\"], [\"ngOverview\", \"\"]],\n    template: function OverviewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµelement(0, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        Éµngcc0.ÉµÉµproperty(\"className\", ctx.divClassName);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return OverviewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * The function used to initialize and return the Overview\r\n   * @type {?}\r\n   */\n  OverviewComponent.prototype.initOverview;\n  /**\r\n   * The div class name that holds the Overview. Use this name to style your Overview in CSS.\r\n   * @type {?}\r\n   */\n\n  OverviewComponent.prototype.divClassName;\n  /**\r\n   * The Diagram to observe with the Overview\r\n   * @type {?}\r\n   */\n\n  OverviewComponent.prototype.observedDiagram;\n  /** @type {?} */\n\n  OverviewComponent.prototype.overviewDiv;\n  /**\r\n   * The Overview itself\r\n   * @type {?}\r\n   */\n\n  OverviewComponent.prototype.overview;\n  /** @type {?} */\n\n  OverviewComponent.prototype.zone;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/data-sync.service.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar DataSyncService = /*#__PURE__*/(function () {\n  var DataSyncService = /*#__PURE__*/function () {\n    function DataSyncService() {\n      _classCallCheck(this, DataSyncService);\n    }\n\n    _createClass(DataSyncService, null, [{\n      key: \"syncNodeData\",\n      value:\n      /**\r\n       * Sync a node data array with a set of changes\r\n       * @param {?} changes The set of changes to the GoJS model\r\n       * @param {?} nodeData The node data array to merge these changes with\r\n       * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'\r\n       * @return {?} A node data array, merged with the changes\r\n       */\n      function syncNodeData(changes, nodeData, model) {\n        if (!changes) return nodeData;\n        if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys) return nodeData; // maintain a map of modified nodes for fast lookup during insertion\n\n        /** @type {?} */\n\n        var modifiedNodesMap = new go.Map(); // nodeData is immutable, modify it using the immer package's \"produce\" function (creates new array)\n\n        /** @type {?} */\n\n        var newNodeDataArray = produce(nodeData,\n        /**\r\n        * @param {?} draft\r\n        * @return {?}\r\n        */\n        function (draft) {\n          // account for modified node data\n          if (changes.modifiedNodeData) {\n            changes.modifiedNodeData.forEach(\n            /**\r\n            * @param {?} nd\r\n            * @return {?}\r\n            */\n            function (nd) {\n              // Get the value of the node key property checking wether is a function or a string\n\n              /** @type {?} */\n              var key = model ? model.getKeyForNodeData(nd) : nd['key'];\n              modifiedNodesMap.set(key, nd);\n\n              for (var i = 0; i < nodeData.length; i++) {\n                /** @type {?} */\n                var ndEntry = nodeData[i];\n                /** @type {?} */\n\n                var keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];\n\n                if (keyNdEntry === key) {\n                  draft[i] = nd;\n                }\n              }\n            });\n          } // account for inserted node data\n\n\n          if (changes.insertedNodeKeys) {\n            changes.insertedNodeKeys.forEach(\n            /**\r\n            * @param {?} key\r\n            * @return {?}\r\n            */\n            function (key) {\n              /** @type {?} */\n              var nd = modifiedNodesMap.get(key);\n\n              if (nd) {\n                draft.push(nd);\n              }\n            });\n          } // account for removed node data\n\n\n          if (changes.removedNodeKeys) {\n            return draft.filter(\n            /**\r\n            * @param {?} nd\r\n            * @return {?}\r\n            */\n            function (nd) {\n              /** @type {?} */\n              var key = model ? model.getKeyForNodeData(nd) : nd['key'];\n\n              if (changes.removedNodeKeys.includes(key)) {\n                return false;\n              }\n\n              return true;\n            });\n          }\n        });\n        return newNodeDataArray;\n      }\n      /**\r\n       * Sync a link data array with a set of changes\r\n       * @param {?} changes The set of changes to the GoJS model\r\n       * @param {?} linkData The link data array to merge these changes with\r\n       * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'\r\n       * @return {?} A link data array, merged with the changes\r\n       */\n\n    }, {\n      key: \"syncLinkData\",\n      value: function syncLinkData(changes, linkData, model) {\n        if (!changes) return linkData;\n        if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys) return linkData; // maintain a map of modified nodes for fast lookup during insertion\n\n        /** @type {?} */\n\n        var modifiedLinksMap = new go.Map(); // linkData is immutable, modify it using the immer package's \"produce\" function (creates new array)\n\n        linkData = produce(linkData,\n        /**\r\n        * @param {?} draft\r\n        * @return {?}\r\n        */\n        function (draft) {\n          // account for modified link data\n          if (changes.modifiedLinkData) {\n            changes.modifiedLinkData.forEach(\n            /**\r\n            * @param {?} ld\r\n            * @return {?}\r\n            */\n            function (ld) {\n              // Get the value of the link key\n\n              /** @type {?} */\n              var key = model ? model.getKeyForLinkData(ld) : ld['key'];\n              modifiedLinksMap.set(key, ld);\n\n              for (var i = 0; i < linkData.length; i++) {\n                /** @type {?} */\n                var ldEntry = linkData[i];\n                /** @type {?} */\n\n                var keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];\n\n                if (keyLdEntry === key) {\n                  draft[i] = ld;\n                }\n              }\n            });\n          } // account for inserted link data\n\n\n          if (changes.insertedLinkKeys) {\n            changes.insertedLinkKeys.forEach(\n            /**\r\n            * @param {?} key\r\n            * @return {?}\r\n            */\n            function (key) {\n              /** @type {?} */\n              var nd = modifiedLinksMap.get(key);\n\n              if (nd) {\n                draft.push(nd);\n              }\n            });\n          } // account for removed link data\n\n\n          if (changes.removedLinkKeys) {\n            return draft.filter(\n            /**\r\n            * @param {?} ld\r\n            * @return {?}\r\n            */\n            function (ld) {\n              /** @type {?} */\n              var key = model ? model.getKeyForLinkData(ld) : ld['key'];\n\n              if (changes.removedLinkKeys.includes(key)) {\n                return false;\n              }\n\n              return true;\n            });\n          }\n        });\n        return linkData;\n      }\n      /**\r\n       * Sync modelData with a set of changes\r\n       * @param {?} changes The set of changes to the GoJS model\r\n       * @param {?} modelData The modelData to merge these changes with\r\n       * @return {?} A modelData object, merged with the changes\r\n       */\n\n    }, {\n      key: \"syncModelData\",\n      value: function syncModelData(changes, modelData) {\n        if (!changes) return modelData;\n        if (!changes.modelData) return modelData;\n\n        if (changes.modelData) {\n          return changes.modelData;\n        }\n      }\n    }]);\n\n    return DataSyncService;\n  }();\n\n  DataSyncService.Éµfac = function DataSyncService_Factory(t) {\n    return new (t || DataSyncService)();\n  };\n\n  DataSyncService.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: DataSyncService,\n    factory: DataSyncService.Éµfac\n  });\n  return DataSyncService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: lib/gojs-angular.module.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar GojsAngularModule = /*#__PURE__*/(function () {\n  var GojsAngularModule = /*#__PURE__*/_createClass(function GojsAngularModule() {\n    _classCallCheck(this, GojsAngularModule);\n  });\n\n  GojsAngularModule.Éµfac = function GojsAngularModule_Factory(t) {\n    return new (t || GojsAngularModule)();\n  };\n\n  GojsAngularModule.Éµmod = /*@__PURE__*/Éµngcc0.ÉµÉµdefineNgModule({\n    type: GojsAngularModule\n  });\n  GojsAngularModule.Éµinj = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjector({\n    providers: [DataSyncService]\n  });\n  return GojsAngularModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(GojsAngularModule, {\n    declarations: [DiagramComponent, OverviewComponent, PaletteComponent],\n    exports: [DiagramComponent, OverviewComponent, PaletteComponent]\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: public-api.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * Generated from: gojs-angular.ts\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nexport { DataSyncService, DiagramComponent, GojsAngularModule, OverviewComponent, PaletteComponent }; //# sourceMappingURL=gojs-angular.js.map","map":null,"metadata":{},"sourceType":"module"}