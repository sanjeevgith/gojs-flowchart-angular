import { EventEmitter, Component, NgZone, Input, Output, ViewChild, Injectable, NgModule } from '@angular/core';
import * as go from 'gojs';
import produce from 'immer';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ng-diagram-helper.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * An interface to allow methods defined below to accept Palette or Diagram Components,
 * without requiring DiagramComponent or PaletteComponent directly in this file
 * (that would create a circular dependency)
 * @record
 */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["ngDiagram"];
const _c1 = ["ngPalette"];
const _c2 = ["ngOverview"];
function IDiagramOrPaletteComponent() { }
if (false) {
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.modelChange;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.zone;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.nodeDataArray;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.linkDataArray;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.modelData;
}
/**
 * Defines some shared helper static functions, used in Diagram / Palette / Overview Components
 */
class NgDiagramHelper {
    constructor() { }
    /**
     * Ensures mousemove event listeners on a diagram's canvas are run outside NgZone.
     * This way, change detection isn't triggered on each mousemove, improving performance.
     *
     * If some state-alteration must happen on a mousemove event inside the diagram, use zone.run() to make sure the event triggers angular change detection.
     * Used by DiagramComponent, PaletteComponent, and OverviewComponent in their ngAfterViewInit lifecycle hooks
     * @param {?} diagram
     * @param {?} zone
     * @return {?}
     */
    static makeMouseMoveRunOutsideAngularZone(diagram, zone) {
        diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
    }
    /**
     * Initialize a given diagram's model with given node / link / model data
     * @param {?} diagram
     * @param {?} nodeDataArray
     * @param {?} linkDataArray
     * @param {?} modelData
     * @return {?}
     */
    static initializeModel(diagram, nodeDataArray, linkDataArray, modelData) {
        diagram.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                if (modelData) {
                    m.assignAllDataProperties(m.modelData, modelData);
                }
                m.mergeNodeDataArray(m.cloneDeep(nodeDataArray));
                if (linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(linkDataArray));
                }
            }), null);
        }));
    }
    /**
     * Initialize the model changed listener for the Palette / Diagram of a given compoennt; ensure it runs inside the component's ngZone.
     * Those changes will be emitted through a the component's modelChange EventEmitter.
     * @param {?} component
     * @return {?}
     */
    static initializeModelChangedListener(component) {
        /** @type {?} */
        var diagram = null;
        if (!(component.hasOwnProperty("diagram")) && !(component.hasOwnProperty("palette")))
            return;
        if (component.hasOwnProperty("diagram"))
            diagram = component["diagram"];
        if (component.hasOwnProperty("palette"))
            diagram = component["palette"];
        component.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished && e.model && !e.model.isReadOnly && component.modelChange) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                component.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    if (dataChanges !== null)
                        component.modelChange.emit(dataChanges);
                }));
            }
        });
        diagram.addModelChangedListener(component.modelChangedListener);
    }
    /**
     * Merge the app-level node / link / model data of a supplied Diagram|Palette Component with its underlying Diagram|Palette model data
     * @param {?} component
     * @param {?=} isInit Whether or not to treat this update as a Diagram initialization
     * @return {?}
     */
    static mergeAppDataWithModel(component, isInit) {
        /** @type {?} */
        var diagram = null;
        if (component.hasOwnProperty("diagram"))
            diagram = component["diagram"];
        if (component.hasOwnProperty("palette"))
            diagram = component["palette"];
        diagram.model.commit((/**
         * @param {?} m
         * @return {?}
         */
        (m) => {
            if (isInit)
                diagram.model.modelData = {};
            // update modelData first, in case bindings on nodes / links depend on model data
            diagram.model.assignAllDataProperties(diagram.model.modelData, component.modelData);
            // merge node / link data
            if (isInit)
                diagram.model.nodeDataArray = [];
            diagram.model.mergeNodeDataArray(component.nodeDataArray);
            if (component.linkDataArray && diagram.model instanceof go.GraphLinksModel) {
                if (isInit)
                    diagram.model.linkDataArray = [];
                diagram.model.mergeLinkDataArray(component.linkDataArray);
            }
        }), isInit ? null : 'update data');
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/diagram.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DiagramComponent {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        /**
         * Link data for diagram. Optional.
         */
        this.linkDataArray = null;
        /**
         * Model data for diagram. Optional.
         */
        this.modelData = null;
        /**
         * Model changed listener function for diagram
         */
        this.modelChangedListener = null;
        /**
         * Whether or not to skip merging app data with GoJS model data (set to true if update is coming from GoJS, false if coming from app-level, usually)
         */
        this.skipsDiagramUpdate = false;
        /**
         * Event emitter -- fires when diagram model changes. Capture this emitted event in parent component
         */
        this.modelChange = new EventEmitter();
        /**
         * The Diagram itself
         */
        this.diagram = null;
        /**
         * An internal flag used to tell ngOnChanges to treat the next sync operation as a Diagram initialization
         */
        this.wasCleared = false;
    }
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.diagramDiv) {
            throw new Error("diagramDiv is not defined");
        }
        this.diagram = this.initDiagram();
        if (!(this.diagram instanceof go.Diagram)) {
            throw new Error("initDiagram function did not return a go.Diagram");
        }
        // reduces change detection on mouse moves, boosting performance
        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.diagram, this.zone);
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function defined in makeMouseMoveRunOutsideAngularZone
        /** @type {?} */
        const divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the diagram model with the provided node / link / model data
        NgDiagramHelper.initializeModel(this.diagram, this.nodeDataArray, this.linkDataArray, this.modelData);
        // initializer model listener
        NgDiagramHelper.initializeModelChangedListener(this);
    } // end ngAfterViewInit
    // end ngAfterViewInit
    /**
     * If a change has occurred on an \@Input property, merge the app-level changes with GoJS
     * @return {?}
     */
    ngOnChanges() {
        if (!this.diagram || !this.diagram.model || this.skipsDiagramUpdate)
            return;
        // if clear was just called, treat this as initial
        if (this.wasCleared) {
            this.diagram.delayInitialization((/**
             * @return {?}
             */
            () => {
                NgDiagramHelper.mergeAppDataWithModel(this, true);
            }));
            this.wasCleared = false;
        }
        else {
            NgDiagramHelper.mergeAppDataWithModel(this);
        }
    } // end ngOnChanges
    // end ngOnChanges
    /**
     * Clears the diagram of all nodes, links, and model data.
     * Also clears the UndoManager history and clipboard.
     * The next state update will be treated as diagram initialization.
     * @return {?}
     */
    clear() {
        /** @type {?} */
        const diagram = this.diagram;
        if (diagram !== null) {
            diagram.clear();
            this.wasCleared = true;
        }
    } // end clear function
    // end clear function
    /**
     * Set this.diagram.div to null, removing all event listeners
     * @return {?}
     */
    ngOnDestroy() {
        this.diagram.div = null; // removes event listeners
    } // end ngOnDestroy function
}
DiagramComponent.ɵfac = function DiagramComponent_Factory(t) { return new (t || DiagramComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DiagramComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DiagramComponent, selectors: [["gojs-diagram"]], viewQuery: function DiagramComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.diagramDiv = _t.first);
    } }, inputs: { linkDataArray: "linkDataArray", modelData: "modelData", skipsDiagramUpdate: "skipsDiagramUpdate", initDiagram: "initDiagram", nodeDataArray: "nodeDataArray", divClassName: "divClassName" }, outputs: { modelChange: "modelChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 1, consts: [[3, "className"], ["ngDiagram", ""]], template: function DiagramComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.divClassName);
    } }, encapsulation: 2 });
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: NgZone }
];
DiagramComponent.propDecorators = {
    initDiagram: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    skipsDiagramUpdate: [{ type: Input }],
    modelChange: [{ type: Output }],
    diagramDiv: [{ type: ViewChild, args: ['ngDiagram', { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DiagramComponent, [{
        type: Component,
        args: [{
                selector: 'gojs-diagram',
                template: '<div #ngDiagram [className]=divClassName></div>'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { linkDataArray: [{
            type: Input
        }], modelData: [{
            type: Input
        }], skipsDiagramUpdate: [{
            type: Input
        }], modelChange: [{
            type: Output
        }], initDiagram: [{
            type: Input
        }], nodeDataArray: [{
            type: Input
        }], divClassName: [{
            type: Input
        }], diagramDiv: [{
            type: ViewChild,
            args: ['ngDiagram', { static: true }]
        }] }); })();
if (false) {
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     * @type {?}
     */
    DiagramComponent.prototype.initDiagram;
    /**
     * Node data for diagram
     * @type {?}
     */
    DiagramComponent.prototype.nodeDataArray;
    /**
     * Link data for diagram. Optional.
     * @type {?}
     */
    DiagramComponent.prototype.linkDataArray;
    /**
     * Model data for diagram. Optional.
     * @type {?}
     */
    DiagramComponent.prototype.modelData;
    /**
     * Diagram div class name. Use this name to style your diagram in CSS.
     * @type {?}
     */
    DiagramComponent.prototype.divClassName;
    /**
     * Model changed listener function for diagram
     * @type {?}
     */
    DiagramComponent.prototype.modelChangedListener;
    /**
     * Whether or not to skip merging app data with GoJS model data (set to true if update is coming from GoJS, false if coming from app-level, usually)
     * @type {?}
     */
    DiagramComponent.prototype.skipsDiagramUpdate;
    /**
     * Event emitter -- fires when diagram model changes. Capture this emitted event in parent component
     * @type {?}
     */
    DiagramComponent.prototype.modelChange;
    /**
     * The DIV element holding the Diagram
     * @type {?}
     */
    DiagramComponent.prototype.diagramDiv;
    /**
     * The Diagram itself
     * @type {?}
     */
    DiagramComponent.prototype.diagram;
    /**
     * An internal flag used to tell ngOnChanges to treat the next sync operation as a Diagram initialization
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.wasCleared;
    /** @type {?} */
    DiagramComponent.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/palette.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaletteComponent {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        /**
         * Link data for palette. Optional.
         */
        this.linkDataArray = null;
        /**
         * Model data for palette. Optional.
         */
        this.modelData = null;
        /**
         * Event emitter -- fires when palette model changes. Capture this emitted event in parent component
         */
        this.modelChange = new EventEmitter();
        /**
         * The Palette itself
         */
        this.palette = null;
    }
    /**
     * Initialize Palette after view init
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.paletteDiv) {
            throw new Error("paletteDiv is not defined");
        }
        this.palette = this.initPalette();
        if (!(this.palette instanceof go.Palette)) {
            throw new Error("initPalette function did not return a go.Palette");
        }
        // reduces change detection on mouse moves, boosting performance
        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.palette, this.zone);
        // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        const divRef = this.paletteDiv.nativeElement;
        if (divRef == null)
            return;
        this.palette.div = divRef;
        // initialize palette model
        NgDiagramHelper.initializeModel(this.palette, this.nodeDataArray, this.linkDataArray, this.modelData);
    }
    /**
     * If a change has occured on an \@Input property, merge the app-level changes with GoJS
     * @return {?}
     */
    ngOnChanges() {
        if (!this.palette || !this.palette.model)
            return;
        NgDiagramHelper.mergeAppDataWithModel(this);
    } // end ngOnChanges 
    // end ngOnChanges 
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.palette.div = null; // removes event listeners
    }
}
PaletteComponent.ɵfac = function PaletteComponent_Factory(t) { return new (t || PaletteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
PaletteComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PaletteComponent, selectors: [["gojs-palette"]], viewQuery: function PaletteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.paletteDiv = _t.first);
    } }, inputs: { linkDataArray: "linkDataArray", modelData: "modelData", initPalette: "initPalette", nodeDataArray: "nodeDataArray", divClassName: "divClassName" }, outputs: { modelChange: "modelChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 1, consts: [[3, "className"], ["ngPalette", ""]], template: function PaletteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.divClassName);
    } }, encapsulation: 2 });
/** @nocollapse */
PaletteComponent.ctorParameters = () => [
    { type: NgZone }
];
PaletteComponent.propDecorators = {
    initPalette: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    modelChange: [{ type: Output }],
    paletteDiv: [{ type: ViewChild, args: ['ngPalette', { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PaletteComponent, [{
        type: Component,
        args: [{
                selector: 'gojs-palette',
                template: '<div #ngPalette [className]=divClassName></div>'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { linkDataArray: [{
            type: Input
        }], modelData: [{
            type: Input
        }], modelChange: [{
            type: Output
        }], initPalette: [{
            type: Input
        }], nodeDataArray: [{
            type: Input
        }], divClassName: [{
            type: Input
        }], paletteDiv: [{
            type: ViewChild,
            args: ['ngPalette', { static: true }]
        }] }); })();
if (false) {
    /**
     * Palette initialization function. Returns a go.Palette.
     * Do not initialize model data in this function.
     * @type {?}
     */
    PaletteComponent.prototype.initPalette;
    /**
     * Node data for palette
     * @type {?}
     */
    PaletteComponent.prototype.nodeDataArray;
    /**
     * Link data for palette. Optional.
     * @type {?}
     */
    PaletteComponent.prototype.linkDataArray;
    /**
     * Model data for palette. Optional.
     * @type {?}
     */
    PaletteComponent.prototype.modelData;
    /**
     * Palette div class name. Use this name to style your palette in CSS
     * @type {?}
     */
    PaletteComponent.prototype.divClassName;
    /**
     * Event emitter -- fires when palette model changes. Capture this emitted event in parent component
     * @type {?}
     */
    PaletteComponent.prototype.modelChange;
    /**
     * The DIV element holding the Palette
     * @type {?}
     */
    PaletteComponent.prototype.paletteDiv;
    /**
     * The Palette itself
     * @type {?}
     */
    PaletteComponent.prototype.palette;
    /** @type {?} */
    PaletteComponent.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/overview.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OverviewComponent {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        /**
         * The Diagram to observe with the Overview
         */
        this.observedDiagram = null;
        /**
         * The Overview itself
         */
        this.overview = null;
    }
    /**
     * Initialize the overview
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.overviewDiv) {
            throw new Error("overviewDiv is not defined");
        }
        if (this.initOverview) {
            this.overview = this.initOverview();
            if (!(this.overview instanceof go.Overview)) {
                throw new Error("initOverview function did not return a go.Overview");
            }
        }
        else {
            this.overview = new go.Overview();
            this.overview.contentAlignment = go.Spot.Center;
        }
        // reduces change detection on mouse moves, boosting performance
        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.overview, this.zone);
        this.overview.div = this.overviewDiv.nativeElement;
    }
    /**
     * Only update when the observed diagram changes
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.overview)
            return;
        if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {
            this.overview.observed = changes.observedDiagram.currentValue;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.overview.div = null; // removes event listeners
    }
}
OverviewComponent.ɵfac = function OverviewComponent_Factory(t) { return new (t || OverviewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
OverviewComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: OverviewComponent, selectors: [["gojs-overview"]], viewQuery: function OverviewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c2, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overviewDiv = _t.first);
    } }, inputs: { observedDiagram: "observedDiagram", initOverview: "initOverview", divClassName: "divClassName" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 1, consts: [[3, "className"], ["ngOverview", ""]], template: function OverviewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.divClassName);
    } }, encapsulation: 2 });
/** @nocollapse */
OverviewComponent.ctorParameters = () => [
    { type: NgZone }
];
OverviewComponent.propDecorators = {
    initOverview: [{ type: Input }],
    divClassName: [{ type: Input }],
    observedDiagram: [{ type: Input }],
    overviewDiv: [{ type: ViewChild, args: ['ngOverview', { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OverviewComponent, [{
        type: Component,
        args: [{
                selector: 'gojs-overview',
                template: '<div #ngOverview [className]=divClassName></div>'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { observedDiagram: [{
            type: Input
        }], initOverview: [{
            type: Input
        }], divClassName: [{
            type: Input
        }], overviewDiv: [{
            type: ViewChild,
            args: ['ngOverview', { static: true }]
        }] }); })();
if (false) {
    /**
     * The function used to initialize and return the Overview
     * @type {?}
     */
    OverviewComponent.prototype.initOverview;
    /**
     * The div class name that holds the Overview. Use this name to style your Overview in CSS.
     * @type {?}
     */
    OverviewComponent.prototype.divClassName;
    /**
     * The Diagram to observe with the Overview
     * @type {?}
     */
    OverviewComponent.prototype.observedDiagram;
    /** @type {?} */
    OverviewComponent.prototype.overviewDiv;
    /**
     * The Overview itself
     * @type {?}
     */
    OverviewComponent.prototype.overview;
    /** @type {?} */
    OverviewComponent.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/data-sync.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataSyncService {
    /**
     * Sync a node data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} nodeData The node data array to merge these changes with
     * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
     * @return {?} A node data array, merged with the changes
     */
    static syncNodeData(changes, nodeData, model) {
        if (!changes)
            return nodeData;
        if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
            return nodeData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedNodesMap = new go.Map();
        // nodeData is immutable, modify it using the immer package's "produce" function (creates new array)
        /** @type {?} */
        var newNodeDataArray = produce(nodeData, (/**
         * @param {?} draft
         * @return {?}
         */
        (draft) => {
            // account for modified node data
            if (changes.modifiedNodeData) {
                changes.modifiedNodeData.forEach((/**
                 * @param {?} nd
                 * @return {?}
                 */
                (nd) => {
                    // Get the value of the node key property checking wether is a function or a string
                    /** @type {?} */
                    const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    modifiedNodesMap.set(key, nd);
                    for (let i = 0; i < nodeData.length; i++) {
                        /** @type {?} */
                        const ndEntry = nodeData[i];
                        /** @type {?} */
                        const keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];
                        if (keyNdEntry === key) {
                            draft[i] = nd;
                        }
                    }
                }));
            }
            // account for inserted node data
            if (changes.insertedNodeKeys) {
                changes.insertedNodeKeys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                (key) => {
                    /** @type {?} */
                    const nd = modifiedNodesMap.get(key);
                    if (nd) {
                        draft.push(nd);
                    }
                }));
            }
            // account for removed node data
            if (changes.removedNodeKeys) {
                return draft.filter((/**
                 * @param {?} nd
                 * @return {?}
                 */
                (nd) => {
                    /** @type {?} */
                    const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    if (changes.removedNodeKeys.includes(key)) {
                        return false;
                    }
                    return true;
                }));
            }
        }));
        return newNodeDataArray;
    }
    /**
     * Sync a link data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} linkData The link data array to merge these changes with
     * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'
     * @return {?} A link data array, merged with the changes
     */
    static syncLinkData(changes, linkData, model) {
        if (!changes)
            return linkData;
        if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
            return linkData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedLinksMap = new go.Map();
        // linkData is immutable, modify it using the immer package's "produce" function (creates new array)
        linkData = produce(linkData, (/**
         * @param {?} draft
         * @return {?}
         */
        draft => {
            // account for modified link data
            if (changes.modifiedLinkData) {
                changes.modifiedLinkData.forEach((/**
                 * @param {?} ld
                 * @return {?}
                 */
                (ld) => {
                    // Get the value of the link key
                    /** @type {?} */
                    const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    modifiedLinksMap.set(key, ld);
                    for (let i = 0; i < linkData.length; i++) {
                        /** @type {?} */
                        const ldEntry = linkData[i];
                        /** @type {?} */
                        const keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];
                        if (keyLdEntry === key) {
                            draft[i] = ld;
                        }
                    }
                }));
            }
            // account for inserted link data
            if (changes.insertedLinkKeys) {
                changes.insertedLinkKeys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                (key) => {
                    /** @type {?} */
                    const nd = modifiedLinksMap.get(key);
                    if (nd) {
                        draft.push(nd);
                    }
                }));
            }
            // account for removed link data
            if (changes.removedLinkKeys) {
                return draft.filter((/**
                 * @param {?} ld
                 * @return {?}
                 */
                (ld) => {
                    /** @type {?} */
                    const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    if (changes.removedLinkKeys.includes(key)) {
                        return false;
                    }
                    return true;
                }));
            }
        }));
        return linkData;
    }
    /**
     * Sync modelData with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} modelData The modelData to merge these changes with
     * @return {?} A modelData object, merged with the changes
     */
    static syncModelData(changes, modelData) {
        if (!changes)
            return modelData;
        if (!changes.modelData)
            return modelData;
        if (changes.modelData) {
            return changes.modelData;
        }
    }
}
DataSyncService.ɵfac = function DataSyncService_Factory(t) { return new (t || DataSyncService)(); };
DataSyncService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DataSyncService, factory: DataSyncService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DataSyncService, [{
        type: Injectable
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/gojs-angular.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GojsAngularModule {
}
GojsAngularModule.ɵfac = function GojsAngularModule_Factory(t) { return new (t || GojsAngularModule)(); };
GojsAngularModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: GojsAngularModule });
GojsAngularModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        DataSyncService
    ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GojsAngularModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    DiagramComponent,
                    OverviewComponent,
                    PaletteComponent
                ],
                imports: [],
                providers: [
                    DataSyncService
                ],
                exports: [
                    DiagramComponent,
                    OverviewComponent,
                    PaletteComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GojsAngularModule, { declarations: [DiagramComponent, OverviewComponent, PaletteComponent], exports: [DiagramComponent, OverviewComponent, PaletteComponent] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: gojs-angular.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DataSyncService, DiagramComponent, GojsAngularModule, OverviewComponent, PaletteComponent };

//# sourceMappingURL=gojs-angular.js.map