/**
 * @fileoverview added by tsickle
 * Generated from: lib/data-sync.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as go from 'gojs';
import produce from "immer";
export class DataSyncService {
    /**
     * Sync a node data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} nodeData The node data array to merge these changes with
     * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
     * @return {?} A node data array, merged with the changes
     */
    static syncNodeData(changes, nodeData, model) {
        if (!changes)
            return nodeData;
        if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
            return nodeData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedNodesMap = new go.Map();
        // nodeData is immutable, modify it using the immer package's "produce" function (creates new array)
        /** @type {?} */
        var newNodeDataArray = produce(nodeData, (/**
         * @param {?} draft
         * @return {?}
         */
        (draft) => {
            // account for modified node data
            if (changes.modifiedNodeData) {
                changes.modifiedNodeData.forEach((/**
                 * @param {?} nd
                 * @return {?}
                 */
                (nd) => {
                    // Get the value of the node key property checking wether is a function or a string
                    /** @type {?} */
                    const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    modifiedNodesMap.set(key, nd);
                    for (let i = 0; i < nodeData.length; i++) {
                        /** @type {?} */
                        const ndEntry = nodeData[i];
                        /** @type {?} */
                        const keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];
                        if (keyNdEntry === key) {
                            draft[i] = nd;
                        }
                    }
                }));
            }
            // account for inserted node data
            if (changes.insertedNodeKeys) {
                changes.insertedNodeKeys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                (key) => {
                    /** @type {?} */
                    const nd = modifiedNodesMap.get(key);
                    if (nd) {
                        draft.push(nd);
                    }
                }));
            }
            // account for removed node data
            if (changes.removedNodeKeys) {
                return draft.filter((/**
                 * @param {?} nd
                 * @return {?}
                 */
                (nd) => {
                    /** @type {?} */
                    const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    if (changes.removedNodeKeys.includes(key)) {
                        return false;
                    }
                    return true;
                }));
            }
        }));
        return newNodeDataArray;
    }
    /**
     * Sync a link data array with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} linkData The link data array to merge these changes with
     * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'
     * @return {?} A link data array, merged with the changes
     */
    static syncLinkData(changes, linkData, model) {
        if (!changes)
            return linkData;
        if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
            return linkData;
        // maintain a map of modified nodes for fast lookup during insertion
        /** @type {?} */
        const modifiedLinksMap = new go.Map();
        // linkData is immutable, modify it using the immer package's "produce" function (creates new array)
        linkData = produce(linkData, (/**
         * @param {?} draft
         * @return {?}
         */
        draft => {
            // account for modified link data
            if (changes.modifiedLinkData) {
                changes.modifiedLinkData.forEach((/**
                 * @param {?} ld
                 * @return {?}
                 */
                (ld) => {
                    // Get the value of the link key
                    /** @type {?} */
                    const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    modifiedLinksMap.set(key, ld);
                    for (let i = 0; i < linkData.length; i++) {
                        /** @type {?} */
                        const ldEntry = linkData[i];
                        /** @type {?} */
                        const keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];
                        if (keyLdEntry === key) {
                            draft[i] = ld;
                        }
                    }
                }));
            }
            // account for inserted link data
            if (changes.insertedLinkKeys) {
                changes.insertedLinkKeys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                (key) => {
                    /** @type {?} */
                    const nd = modifiedLinksMap.get(key);
                    if (nd) {
                        draft.push(nd);
                    }
                }));
            }
            // account for removed link data
            if (changes.removedLinkKeys) {
                return draft.filter((/**
                 * @param {?} ld
                 * @return {?}
                 */
                (ld) => {
                    /** @type {?} */
                    const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    if (changes.removedLinkKeys.includes(key)) {
                        return false;
                    }
                    return true;
                }));
            }
        }));
        return linkData;
    }
    /**
     * Sync modelData with a set of changes
     * @param {?} changes The set of changes to the GoJS model
     * @param {?} modelData The modelData to merge these changes with
     * @return {?} A modelData object, merged with the changes
     */
    static syncModelData(changes, modelData) {
        if (!changes)
            return modelData;
        if (!changes.modelData)
            return modelData;
        if (changes.modelData) {
            return changes.modelData;
        }
    }
}
DataSyncService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1zeW5jLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvcmpvaG4vRG9jdW1lbnRzL0dpdEh1Yi9nb2pzLWFuZ3VsYXIvcHJvamVjdHMvZ29qcy1hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9kYXRhLXN5bmMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDM0IsT0FBTyxPQUFPLE1BQU0sT0FBTyxDQUFDO0FBRzVCLE1BQU0sT0FBTyxlQUFlOzs7Ozs7OztJQVNuQixNQUFNLENBQUMsWUFBWSxDQUFDLE9BQTJCLEVBQUUsUUFBOEIsRUFBRSxLQUFnQjtRQUN0RyxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sUUFBUSxDQUFDO1FBQzlCLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZTtZQUFFLE9BQU8sUUFBUSxDQUFDOzs7Y0FHbEcsZ0JBQWdCLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUF5Qjs7O1lBR3hELGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxRQUFROzs7O1FBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNqRCxpQ0FBaUM7WUFDakMsSUFBSSxPQUFPLENBQUMsZ0JBQWdCLEVBQUU7Z0JBQzVCLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPOzs7O2dCQUFDLENBQUMsRUFBaUIsRUFBRSxFQUFFOzs7MEJBRS9DLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztvQkFDM0QsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFF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QyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDckIsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDO1NBQzFCO0lBQ0gsQ0FBQzs7O1lBaklGLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGdvIGZyb20gJ2dvanMnO1xyXG5pbXBvcnQgcHJvZHVjZSBmcm9tIFwiaW1tZXJcIjtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIERhdGFTeW5jU2VydmljZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN5bmMgYSBub2RlIGRhdGEgYXJyYXkgd2l0aCBhIHNldCBvZiBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgVGhlIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBHb0pTIG1vZGVsXHJcbiAgICogQHBhcmFtIG5vZGVEYXRhIFRoZSBub2RlIGRhdGEgYXJyYXkgdG8gbWVyZ2UgdGhlc2UgY2hhbmdlcyB3aXRoXHJcbiAgICogQHBhcmFtIG1vZGVsIFJlcXVpcmVkIGlmIHlvdSBoYXZlIGRlZmluZWQgeW91ciBtb2RlbC5ub2RlS2V5UHJvcGVydHkgdG8gYmUgc29tZXRoaW5nIG90aGVyIHRoYW4gJ2tleSdcclxuICAgKiBAcmV0dXJucyBBIG5vZGUgZGF0YSBhcnJheSwgbWVyZ2VkIHdpdGggdGhlIGNoYW5nZXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHN5bmNOb2RlRGF0YShjaGFuZ2VzOiBnby5JbmNyZW1lbnRhbERhdGEsIG5vZGVEYXRhOiBBcnJheTxnby5PYmplY3REYXRhPiwgbW9kZWw/OiBnby5Nb2RlbCkge1xyXG4gICAgaWYgKCFjaGFuZ2VzKSByZXR1cm4gbm9kZURhdGE7XHJcbiAgICBpZiAoIWNoYW5nZXMubW9kaWZpZWROb2RlRGF0YSAmJiAhY2hhbmdlcy5pbnNlcnRlZE5vZGVLZXlzICYmICFjaGFuZ2VzLnJlbW92ZWROb2RlS2V5cykgcmV0dXJuIG5vZGVEYXRhO1xyXG5cclxuICAgIC8vIG1haW50YWluIGEgbWFwIG9mIG1vZGlmaWVkIG5vZGVzIGZvciBmYXN0IGxvb2t1cCBkdXJpbmcgaW5zZXJ0aW9uXHJcbiAgICBjb25zdCBtb2RpZmllZE5vZGVzTWFwID0gbmV3IGdvLk1hcDxnby5LZXksIGdvLk9iamVjdERhdGE+KCk7XHJcblxyXG4gICAgLy8gbm9kZURhdGEgaXMgaW1tdXRhYmxlLCBtb2RpZnkgaXQgdXNpbmcgdGhlIGltbWVyIHBhY2thZ2UncyBcInByb2R1Y2VcIiBmdW5jdGlvbiAoY3JlYXRlcyBuZXcgYXJyYXkpXHJcbiAgICB2YXIgbmV3Tm9kZURhdGFBcnJheSA9IHByb2R1Y2Uobm9kZURhdGEsIChkcmFmdCkgPT4ge1xyXG4gICAgICAvLyBhY2NvdW50IGZvciBtb2RpZmllZCBub2RlIGRhdGFcclxuICAgICAgaWYgKGNoYW5nZXMubW9kaWZpZWROb2RlRGF0YSkge1xyXG4gICAgICAgIGNoYW5nZXMubW9kaWZpZWROb2RlRGF0YS5mb3JFYWNoKChuZDogZ28uT2JqZWN0RGF0YSkgPT4ge1xyXG4gICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBrZXkgcHJvcGVydHkgY2hlY2tpbmcgd2V0aGVyIGlzIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcclxuICAgICAgICAgIGNvbnN0IGtleSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTm9kZURhdGEobmQpIDogbmRbJ2tleSddO1xyXG4gICAgICAgICAgbW9kaWZpZWROb2Rlc01hcC5zZXQoa2V5LCBuZCk7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5kRW50cnkgPSBub2RlRGF0YVtpXTtcclxuICAgICAgICAgICAgY29uc3Qga2V5TmRFbnRyeSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTm9kZURhdGEobmRFbnRyeSkgOiBuZEVudHJ5WydrZXknXTtcclxuICAgICAgICAgICAgaWYgKGtleU5kRW50cnkgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgIGRyYWZ0W2ldID0gbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWNjb3VudCBmb3IgaW5zZXJ0ZWQgbm9kZSBkYXRhXHJcbiAgICAgIGlmIChjaGFuZ2VzLmluc2VydGVkTm9kZUtleXMpIHtcclxuICAgICAgICBjaGFuZ2VzLmluc2VydGVkTm9kZUtleXMuZm9yRWFjaCgoa2V5OiBnby5LZXkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5kID0gbW9kaWZpZWROb2Rlc01hcC5nZXQoa2V5KTtcclxuICAgICAgICAgIGlmIChuZCkge1xyXG4gICAgICAgICAgICBkcmFmdC5wdXNoKG5kKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWNjb3VudCBmb3IgcmVtb3ZlZCBub2RlIGRhdGFcclxuICAgICAgaWYgKGNoYW5nZXMucmVtb3ZlZE5vZGVLZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRyYWZ0LmZpbHRlcigobmQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGtleSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTm9kZURhdGEobmQpIDogbmRbJ2tleSddO1xyXG4gICAgICAgICAgaWYgKGNoYW5nZXMucmVtb3ZlZE5vZGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfSBcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3Tm9kZURhdGFBcnJheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN5bmMgYSBsaW5rIGRhdGEgYXJyYXkgd2l0aCBhIHNldCBvZiBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgVGhlIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBHb0pTIG1vZGVsXHJcbiAgICogQHBhcmFtIGxpbmtEYXRhIFRoZSBsaW5rIGRhdGEgYXJyYXkgdG8gbWVyZ2UgdGhlc2UgY2hhbmdlcyB3aXRoXHJcbiAgICogQHBhcmFtIG1vZGVsIFJlcXVpcmVkIGlmIHlvdSBoYXZlIGRlZmluZWQgeW91ciBtb2RlbC5saW5rS2V5UHJvcGVydHkgdG8gYmUgc29tZXRoaW5nIG90aGVyIHRoYW4gJ2tleSdcclxuICAgKiBAcmV0dXJucyBBIGxpbmsgZGF0YSBhcnJheSwgbWVyZ2VkIHdpdGggdGhlIGNoYW5nZXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHN5bmNMaW5rRGF0YShjaGFuZ2VzOiBnby5JbmNyZW1lbnRhbERhdGEsIGxpbmtEYXRhOiBBcnJheTxnby5PYmplY3REYXRhPiwgbW9kZWw/OiBnby5HcmFwaExpbmtzTW9kZWwpIHtcclxuICAgIGlmICghY2hhbmdlcykgcmV0dXJuIGxpbmtEYXRhO1xyXG4gICAgaWYgKCFjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEgJiYgIWNoYW5nZXMuaW5zZXJ0ZWRMaW5rS2V5cyAmJiAhY2hhbmdlcy5yZW1vdmVkTGlua0tleXMpIHJldHVybiBsaW5rRGF0YTtcclxuXHJcbiAgICAvLyBtYWludGFpbiBhIG1hcCBvZiBtb2RpZmllZCBub2RlcyBmb3IgZmFzdCBsb29rdXAgZHVyaW5nIGluc2VydGlvblxyXG4gICAgY29uc3QgbW9kaWZpZWRMaW5rc01hcCA9IG5ldyBnby5NYXA8Z28uS2V5LCBnby5PYmplY3REYXRhPigpO1xyXG5cclxuICAgIC8vIGxpbmtEYXRhIGlzIGltbXV0YWJsZSwgbW9kaWZ5IGl0IHVzaW5nIHRoZSBpbW1lciBwYWNrYWdlJ3MgXCJwcm9kdWNlXCIgZnVuY3Rpb24gKGNyZWF0ZXMgbmV3IGFycmF5KVxyXG4gICAgbGlua0RhdGEgPSBwcm9kdWNlKGxpbmtEYXRhLCBkcmFmdCA9PiB7XHJcbiAgICAgIC8vIGFjY291bnQgZm9yIG1vZGlmaWVkIGxpbmsgZGF0YVxyXG4gICAgICBpZiAoY2hhbmdlcy5tb2RpZmllZExpbmtEYXRhKSB7XHJcbiAgICAgICAgY2hhbmdlcy5tb2RpZmllZExpbmtEYXRhLmZvckVhY2goKGxkOiBnby5PYmplY3REYXRhKSA9PiB7XHJcbiAgICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBsaW5rIGtleVxyXG4gICAgICAgICAgY29uc3Qga2V5ID0gbW9kZWwgPyBtb2RlbC5nZXRLZXlGb3JMaW5rRGF0YShsZCkgOiBsZFsna2V5J107XHJcbiAgICAgICAgICBtb2RpZmllZExpbmtzTWFwLnNldChrZXksIGxkKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxkRW50cnkgPSBsaW5rRGF0YVtpXTtcclxuICAgICAgICAgICAgY29uc3Qga2V5TGRFbnRyeSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTGlua0RhdGEobGRFbnRyeSkgOiBsZEVudHJ5WydrZXknXTtcclxuICAgICAgICAgICAgaWYgKGtleUxkRW50cnkgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgIGRyYWZ0W2ldID0gbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWNjb3VudCBmb3IgaW5zZXJ0ZWQgbGluayBkYXRhXHJcbiAgICAgIGlmIChjaGFuZ2VzLmluc2VydGVkTGlua0tleXMpIHtcclxuICAgICAgICBjaGFuZ2VzLmluc2VydGVkTGlua0tleXMuZm9yRWFjaCgoa2V5OiBnby5LZXkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5kID0gbW9kaWZpZWRMaW5rc01hcC5nZXQoa2V5KTtcclxuICAgICAgICAgIGlmIChuZCkge1xyXG4gICAgICAgICAgICBkcmFmdC5wdXNoKG5kKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWNjb3VudCBmb3IgcmVtb3ZlZCBsaW5rIGRhdGFcclxuICAgICAgaWYgKGNoYW5nZXMucmVtb3ZlZExpbmtLZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRyYWZ0LmZpbHRlcigobGQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGtleSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTGlua0RhdGEobGQpIDogbGRbJ2tleSddO1xyXG4gICAgICAgICAgaWYgKGNoYW5nZXMucmVtb3ZlZExpbmtLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmtEYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3luYyBtb2RlbERhdGEgd2l0aCBhIHNldCBvZiBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgVGhlIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBHb0pTIG1vZGVsXHJcbiAgICogQHBhcmFtIG1vZGVsRGF0YSBUaGUgbW9kZWxEYXRhIHRvIG1lcmdlIHRoZXNlIGNoYW5nZXMgd2l0aFxyXG4gICAqIEByZXR1cm5zIEEgbW9kZWxEYXRhIG9iamVjdCwgbWVyZ2VkIHdpdGggdGhlIGNoYW5nZXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHN5bmNNb2RlbERhdGEoY2hhbmdlczogZ28uSW5jcmVtZW50YWxEYXRhLCBtb2RlbERhdGE6IGdvLk9iamVjdERhdGEpIHtcclxuICAgIGlmICghY2hhbmdlcykgcmV0dXJuIG1vZGVsRGF0YTtcclxuICAgIGlmICghY2hhbmdlcy5tb2RlbERhdGEpIHJldHVybiBtb2RlbERhdGE7XHJcbiAgICBpZiAoY2hhbmdlcy5tb2RlbERhdGEpIHtcclxuICAgICAgcmV0dXJuIGNoYW5nZXMubW9kZWxEYXRhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG59XHJcbiJdfQ==