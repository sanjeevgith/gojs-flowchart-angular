/**
 * @fileoverview added by tsickle
 * Generated from: lib/ng-diagram-helper.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as go from "gojs";
/**
 * An interface to allow methods defined below to accept Palette or Diagram Components,
 * without requiring DiagramComponent or PaletteComponent directly in this file
 * (that would create a circular dependency)
 * @record
 */
export function IDiagramOrPaletteComponent() { }
if (false) {
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.modelChange;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.zone;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.nodeDataArray;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.linkDataArray;
    /** @type {?} */
    IDiagramOrPaletteComponent.prototype.modelData;
}
/**
 * Defines some shared helper static functions, used in Diagram / Palette / Overview Components
 */
export class NgDiagramHelper {
    constructor() { }
    /**
     * Ensures mousemove event listeners on a diagram's canvas are run outside NgZone.
     * This way, change detection isn't triggered on each mousemove, improving performance.
     *
     * If some state-alteration must happen on a mousemove event inside the diagram, use zone.run() to make sure the event triggers angular change detection.
     * Used by DiagramComponent, PaletteComponent, and OverviewComponent in their ngAfterViewInit lifecycle hooks
     * @param {?} diagram
     * @param {?} zone
     * @return {?}
     */
    static makeMouseMoveRunOutsideAngularZone(diagram, zone) {
        diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
    }
    /**
     * Initialize a given diagram's model with given node / link / model data
     * @param {?} diagram
     * @param {?} nodeDataArray
     * @param {?} linkDataArray
     * @param {?} modelData
     * @return {?}
     */
    static initializeModel(diagram, nodeDataArray, linkDataArray, modelData) {
        diagram.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                if (modelData) {
                    m.assignAllDataProperties(m.modelData, modelData);
                }
                m.mergeNodeDataArray(m.cloneDeep(nodeDataArray));
                if (linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(linkDataArray));
                }
            }), null);
        }));
    }
    /**
     * Initialize the model changed listener for the Palette / Diagram of a given compoennt; ensure it runs inside the component's ngZone.
     * Those changes will be emitted through a the component's modelChange EventEmitter.
     * @param {?} component
     * @return {?}
     */
    static initializeModelChangedListener(component) {
        /** @type {?} */
        var diagram = null;
        if (!(component.hasOwnProperty("diagram")) && !(component.hasOwnProperty("palette")))
            return;
        if (component.hasOwnProperty("diagram"))
            diagram = component["diagram"];
        if (component.hasOwnProperty("palette"))
            diagram = component["palette"];
        component.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished && e.model && !e.model.isReadOnly && component.modelChange) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                component.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    if (dataChanges !== null)
                        component.modelChange.emit(dataChanges);
                }));
            }
        });
        diagram.addModelChangedListener(component.modelChangedListener);
    }
    /**
     * Merge the app-level node / link / model data of a supplied Diagram|Palette Component with its underlying Diagram|Palette model data
     * @param {?} component
     * @param {?=} isInit Whether or not to treat this update as a Diagram initialization
     * @return {?}
     */
    static mergeAppDataWithModel(component, isInit) {
        /** @type {?} */
        var diagram = null;
        if (component.hasOwnProperty("diagram"))
            diagram = component["diagram"];
        if (component.hasOwnProperty("palette"))
            diagram = component["palette"];
        diagram.model.commit((/**
         * @param {?} m
         * @return {?}
         */
        (m) => {
            if (isInit)
                diagram.model.modelData = {};
            // update modelData first, in case bindings on nodes / links depend on model data
            diagram.model.assignAllDataProperties(diagram.model.modelData, component.modelData);
            // merge node / link data
            if (isInit)
                diagram.model.nodeDataArray = [];
            diagram.model.mergeNodeDataArray(component.nodeDataArray);
            if (component.linkDataArray && diagram.model instanceof go.GraphLinksModel) {
                if (isInit)
                    diagram.model.linkDataArray = [];
                diagram.model.mergeLinkDataArray(component.linkDataArray);
            }
        }), isInit ? null : 'update data');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctZGlhZ3JhbS1oZWxwZXIuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvcmpvaG4vRG9jdW1lbnRzL0dpdEh1Yi9nb2pzLWFuZ3VsYXIvcHJvamVjdHMvZ29qcy1hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9uZy1kaWFncmFtLWhlbHBlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUVBLE9BQU8sS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7Ozs7O0FBUTNCLGdEQU1DOzs7SUFMQyxpREFBOEM7O0lBQzlDLDBDQUFhOztJQUNiLG1EQUFvQzs7SUFDcEMsbURBQW9DOztJQUNwQywrQ0FBd0I7Ozs7O0FBTTFCLE1BQU0sT0FBTyxlQUFlO0lBQzFCLGdCQUFlLENBQUM7Ozs7Ozs7Ozs7O0lBV1QsTUFBTSxDQUFDLGtDQUFrQyxDQUFDLE9BQW1CLEVBQUUsSUFBWTtRQUNoRixPQUFPLENBQUMsZ0JBQWdCOzs7Ozs7O1FBQUcsQ0FBQyxVQUF1QyxFQUFFLElBQVksRUFBRSxRQUFhLEVBQUUsT0FBZ0IsRUFBRSxFQUFFOztrQkFDOUcscUJBQXFCLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsZ0JBQWdCO1lBQ25FLElBQUksSUFBSSxLQUFLLFdBQVcsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLGlCQUFpQjs7O2dCQUFDLEdBQUcsRUFBRSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUMsQ0FBQzthQUNyRztpQkFBTTtnQkFDTCxJQUFJLENBQUMsR0FBRzs7O2dCQUFDLEdBQUcsRUFBRTtvQkFDWixxQkFBcUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUN4RSxDQUFDLEVBQUMsQ0FBQzthQUNKO1FBQ0gsQ0FBQyxDQUFBLENBQUM7SUFD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QUFTLEVBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3BGLHlCQUF5QjtZQUN6QixJQUFJLE1BQU07Z0JBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1lBQzdDLE9BQU8sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzFELElBQUksU0FBUyxDQUFDLGFBQWEsSUFBSSxPQUFPLENBQUMsS0FBSyxZQUFZLEVBQUUsQ0FBQyxlQUFlLEVBQUU7Z0JBQzFFLElBQUksTUFBTTtvQkFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7Z0JBQzdDLE9BQU8sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQzNEO1FBQ0gsQ0FBQyxHQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUVwQyxDQUFDO0NBRUYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ1pvbmUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XHJcbmltcG9ydCAqIGFzIGdvIGZyb20gXCJnb2pzXCI7XHJcbmltcG9ydCB7IERpYWdyYW1Db21wb25lbnQgfSBmcm9tIFwiLi9kaWFncmFtLmNvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGludGVyZmFjZSB0byBhbGxvdyBtZXRob2RzIGRlZmluZWQgYmVsb3cgdG8gYWNjZXB0IFBhbGV0dGUgb3IgRGlhZ3JhbSBDb21wb25lbnRzLFxyXG4gKiB3aXRob3V0IHJlcXVpcmluZyBEaWFncmFtQ29tcG9uZW50IG9yIFBhbGV0dGVDb21wb25lbnQgZGlyZWN0bHkgaW4gdGhpcyBmaWxlXHJcbiAqICh0aGF0IHdvdWxkIGNyZWF0ZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3kpXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElEaWFncmFtT3JQYWxldHRlQ29tcG9uZW50IHtcclxuICBtb2RlbENoYW5nZTogRXZlbnRFbWl0dGVyPGdvLkluY3JlbWVudGFsRGF0YT4sXHJcbiAgem9uZTogTmdab25lLFxyXG4gIG5vZGVEYXRhQXJyYXk6IEFycmF5PGdvLk9iamVjdERhdGE+LFxyXG4gIGxpbmtEYXRhQXJyYXk6IEFycmF5PGdvLk9iamVjdERhdGE+LFxyXG4gIG1vZGVsRGF0YTogZ28uT2JqZWN0RGF0YVxyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lcyBzb21lIHNoYXJlZCBoZWxwZXIgc3RhdGljIGZ1bmN0aW9ucywgdXNlZCBpbiBEaWFncmFtIC8gUGFsZXR0ZSAvIE92ZXJ2aWV3IENvbXBvbmVudHNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBOZ0RpYWdyYW1IZWxwZXJ7XHJcbiAgY29uc3RydWN0b3IoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFbnN1cmVzIG1vdXNlbW92ZSBldmVudCBsaXN0ZW5lcnMgb24gYSBkaWFncmFtJ3MgY2FudmFzIGFyZSBydW4gb3V0c2lkZSBOZ1pvbmUuXHJcbiAgICogVGhpcyB3YXksIGNoYW5nZSBkZXRlY3Rpb24gaXNuJ3QgdHJpZ2dlcmVkIG9uIGVhY2ggbW91c2Vtb3ZlLCBpbXByb3ZpbmcgcGVyZm9ybWFuY2UuXHJcbiAgICpcclxuICAgKiBJZiBzb21lIHN0YXRlLWFsdGVyYXRpb24gbXVzdCBoYXBwZW4gb24gYSBtb3VzZW1vdmUgZXZlbnQgaW5zaWRlIHRoZSBkaWFncmFtLCB1c2Ugem9uZS5ydW4oKSB0byBtYWtlIHN1cmUgdGhlIGV2ZW50IHRyaWdnZXJzIGFuZ3VsYXIgY2hhbmdlIGRldGVjdGlvbi5cclxuICAgKiBVc2VkIGJ5IERpYWdyYW1Db21wb25lbnQsIFBhbGV0dGVDb21wb25lbnQsIGFuZCBPdmVydmlld0NvbXBvbmVudCBpbiB0aGVpciBuZ0FmdGVyVmlld0luaXQgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICogQHBhcmFtIGRpYWdyYW1cclxuICAgKiBAcGFyYW0gem9uZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgbWFrZU1vdXNlTW92ZVJ1bk91dHNpZGVBbmd1bGFyWm9uZShkaWFncmFtOiBnby5EaWFncmFtLCB6b25lOiBOZ1pvbmUpIHtcclxuICAgIGRpYWdyYW0uYWRkRXZlbnRMaXN0ZW5lciA9IChET01FbGVtZW50OiBFbGVtZW50IHwgV2luZG93IHwgRG9jdW1lbnQsIG5hbWU6IHN0cmluZywgbGlzdGVuZXI6IGFueSwgY2FwdHVyZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICBjb25zdCBzdXBlckFkZEV2ZW50TGlzdGVuZXIgPSBnby5EaWFncmFtLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xyXG4gICAgICBpZiAobmFtZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHN1cGVyQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIERPTUVsZW1lbnQsIG5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgc3VwZXJBZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgRE9NRWxlbWVudCwgbmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBhIGdpdmVuIGRpYWdyYW0ncyBtb2RlbCB3aXRoIGdpdmVuIG5vZGUgLyBsaW5rIC8gbW9kZWwgZGF0YVxyXG4gICAqIEBwYXJhbSBkaWFncmFtXHJcbiAgICogQHBhcmFtIG5vZGVEYXRhQXJyYXlcclxuICAgKiBAcGFyYW0gbGlua0RhdGFBcnJheVxyXG4gICAqIEBwYXJhbSBtb2RlbERhdGFcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemVNb2RlbChkaWFncmFtOiBnby5EaWFncmFtIHwgZ28uUGFsZXR0ZSwgbm9kZURhdGFBcnJheTogQXJyYXk8Z28uT2JqZWN0RGF0YT4sIGxpbmtEYXRhQXJyYXk6IEFycmF5PGdvLk9iamVjdERhdGE+LCBtb2RlbERhdGE6IGdvLk9iamVjdERhdGEpIHtcclxuICAgIGRpYWdyYW0uZGVsYXlJbml0aWFsaXphdGlvbigoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vZGVsID0gZGlhZ3JhbS5tb2RlbDtcclxuICAgICAgbW9kZWwuY29tbWl0KChtOiBnby5Nb2RlbCkgPT4ge1xyXG4gICAgICAgIGlmIChtb2RlbERhdGEpIHtcclxuICAgICAgICAgIG0uYXNzaWduQWxsRGF0YVByb3BlcnRpZXMobS5tb2RlbERhdGEsIG1vZGVsRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG0ubWVyZ2VOb2RlRGF0YUFycmF5KG0uY2xvbmVEZWVwKG5vZGVEYXRhQXJyYXkpKTtcclxuICAgICAgICBpZiAobGlua0RhdGFBcnJheSAmJiBtIGluc3RhbmNlb2YgZ28uR3JhcGhMaW5rc01vZGVsKSB7XHJcbiAgICAgICAgICBtLm1lcmdlTGlua0RhdGFBcnJheShtLmNsb25lRGVlcChsaW5rRGF0YUFycmF5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBudWxsKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgbW9kZWwgY2hhbmdlZCBsaXN0ZW5lciBmb3IgdGhlIFBhbGV0dGUgLyBEaWFncmFtIG9mIGEgZ2l2ZW4gY29tcG9lbm50OyBlbnN1cmUgaXQgcnVucyBpbnNpZGUgdGhlIGNvbXBvbmVudCdzIG5nWm9uZS5cclxuICAgKiBUaG9zZSBjaGFuZ2VzIHdpbGwgYmUgZW1pdHRlZCB0aHJvdWdoIGEgdGhlIGNvbXBvbmVudCdzIG1vZGVsQ2hhbmdlIEV2ZW50RW1pdHRlci5cclxuICAgKiBAcGFyYW0gY29tcG9uZW50XHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplTW9kZWxDaGFuZ2VkTGlzdGVuZXIoY29tcG9uZW50OiBEaWFncmFtQ29tcG9uZW50KSB7XHJcbiAgICB2YXIgZGlhZ3JhbSA9IG51bGw7XHJcbiAgICBpZiAoIShjb21wb25lbnQuaGFzT3duUHJvcGVydHkoXCJkaWFncmFtXCIpKSAmJiAhKGNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eShcInBhbGV0dGVcIikpKSByZXR1cm47XHJcbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KFwiZGlhZ3JhbVwiKSkgZGlhZ3JhbSA9IGNvbXBvbmVudFtcImRpYWdyYW1cIl07XHJcbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KFwicGFsZXR0ZVwiKSkgZGlhZ3JhbSA9IGNvbXBvbmVudFtcInBhbGV0dGVcIl07XHJcbiAgICBjb21wb25lbnQubW9kZWxDaGFuZ2VkTGlzdGVuZXIgPSAoZTogZ28uQ2hhbmdlZEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChlLmlzVHJhbnNhY3Rpb25GaW5pc2hlZCAmJiBlLm1vZGVsICYmICFlLm1vZGVsLmlzUmVhZE9ubHkgJiYgY29tcG9uZW50Lm1vZGVsQ2hhbmdlKSB7XHJcbiAgICAgICAgLy8gdGhpcyBtdXN0IGJlIGRvbmUgd2l0aGluIGEgTmdab25lLnJ1biBibG9jaywgc28gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaW4gdGhlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICBjb21wb25lbnQuem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZGF0YUNoYW5nZXMgPSBlLm1vZGVsIS50b0luY3JlbWVudGFsRGF0YShlKTtcclxuICAgICAgICAgIGlmIChkYXRhQ2hhbmdlcyAhPT0gbnVsbCkgY29tcG9uZW50Lm1vZGVsQ2hhbmdlLmVtaXQoZGF0YUNoYW5nZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgZGlhZ3JhbS5hZGRNb2RlbENoYW5nZWRMaXN0ZW5lcihjb21wb25lbnQubW9kZWxDaGFuZ2VkTGlzdGVuZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2UgdGhlIGFwcC1sZXZlbCBub2RlIC8gbGluayAvIG1vZGVsIGRhdGEgb2YgYSBzdXBwbGllZCBEaWFncmFtfFBhbGV0dGUgQ29tcG9uZW50IHdpdGggaXRzIHVuZGVybHlpbmcgRGlhZ3JhbXxQYWxldHRlIG1vZGVsIGRhdGFcclxuICAgKiBAcGFyYW0gY29tcG9uZW50XHJcbiAgICogQHBhcmFtIGlzSW5pdCBXaGV0aGVyIG9yIG5vdCB0byB0cmVhdCB0aGlzIHVwZGF0ZSBhcyBhIERpYWdyYW0gaW5pdGlhbGl6YXRpb25cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIG1lcmdlQXBwRGF0YVdpdGhNb2RlbChjb21wb25lbnQ6IElEaWFncmFtT3JQYWxldHRlQ29tcG9uZW50LCBpc0luaXQ/OiBib29sZWFuKSB7XHJcbiAgICB2YXIgZGlhZ3JhbSA9IG51bGw7XHJcbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KFwiZGlhZ3JhbVwiKSkgZGlhZ3JhbSA9IGNvbXBvbmVudFtcImRpYWdyYW1cIl07XHJcbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KFwicGFsZXR0ZVwiKSkgZGlhZ3JhbSA9IGNvbXBvbmVudFtcInBhbGV0dGVcIl07XHJcblxyXG4gICAgZGlhZ3JhbS5tb2RlbC5jb21taXQoKG06IGdvLk1vZGVsKSA9PiB7XHJcbiAgICAgIGlmIChpc0luaXQpIGRpYWdyYW0ubW9kZWwubW9kZWxEYXRhID0ge307XHJcbiAgICAgIC8vIHVwZGF0ZSBtb2RlbERhdGEgZmlyc3QsIGluIGNhc2UgYmluZGluZ3Mgb24gbm9kZXMgLyBsaW5rcyBkZXBlbmQgb24gbW9kZWwgZGF0YVxyXG4gICAgICBkaWFncmFtLm1vZGVsLmFzc2lnbkFsbERhdGFQcm9wZXJ0aWVzKGRpYWdyYW0ubW9kZWwubW9kZWxEYXRhLCBjb21wb25lbnQubW9kZWxEYXRhKTtcclxuICAgICAgLy8gbWVyZ2Ugbm9kZSAvIGxpbmsgZGF0YVxyXG4gICAgICBpZiAoaXNJbml0KSBkaWFncmFtLm1vZGVsLm5vZGVEYXRhQXJyYXkgPSBbXTtcclxuICAgICAgZGlhZ3JhbS5tb2RlbC5tZXJnZU5vZGVEYXRhQXJyYXkoY29tcG9uZW50Lm5vZGVEYXRhQXJyYXkpO1xyXG4gICAgICBpZiAoY29tcG9uZW50LmxpbmtEYXRhQXJyYXkgJiYgZGlhZ3JhbS5tb2RlbCBpbnN0YW5jZW9mIGdvLkdyYXBoTGlua3NNb2RlbCkge1xyXG4gICAgICAgIGlmIChpc0luaXQpIGRpYWdyYW0ubW9kZWwubGlua0RhdGFBcnJheSA9IFtdO1xyXG4gICAgICAgIGRpYWdyYW0ubW9kZWwubWVyZ2VMaW5rRGF0YUFycmF5KGNvbXBvbmVudC5saW5rRGF0YUFycmF5KTtcclxuICAgICAgfVxyXG4gICAgfSwgaXNJbml0ID8gbnVsbCA6ICd1cGRhdGUgZGF0YScpO1xyXG5cclxuICB9XHJcblxyXG59XHJcbiJdfQ==