(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('gojs'), require('immer')) :
    typeof define === 'function' && define.amd ? define('gojs-angular', ['exports', '@angular/core', 'gojs', 'immer'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['gojs-angular'] = {}, global.ng.core, global.go, global.produce));
}(this, (function (exports, core, go, produce) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var go__namespace = /*#__PURE__*/_interopNamespace(go);
    var produce__default = /*#__PURE__*/_interopDefaultLegacy(produce);

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/ng-diagram-helper.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * An interface to allow methods defined below to accept Palette or Diagram Components,
     * without requiring DiagramComponent or PaletteComponent directly in this file
     * (that would create a circular dependency)
     * @record
     */
    function IDiagramOrPaletteComponent() { }
    if (false) {
        /** @type {?} */
        IDiagramOrPaletteComponent.prototype.modelChange;
        /** @type {?} */
        IDiagramOrPaletteComponent.prototype.zone;
        /** @type {?} */
        IDiagramOrPaletteComponent.prototype.nodeDataArray;
        /** @type {?} */
        IDiagramOrPaletteComponent.prototype.linkDataArray;
        /** @type {?} */
        IDiagramOrPaletteComponent.prototype.modelData;
    }
    /**
     * Defines some shared helper static functions, used in Diagram / Palette / Overview Components
     */
    var NgDiagramHelper = /** @class */ (function () {
        function NgDiagramHelper() {
        }
        /**
         * Ensures mousemove event listeners on a diagram's canvas are run outside NgZone.
         * This way, change detection isn't triggered on each mousemove, improving performance.
         *
         * If some state-alteration must happen on a mousemove event inside the diagram, use zone.run() to make sure the event triggers angular change detection.
         * Used by DiagramComponent, PaletteComponent, and OverviewComponent in their ngAfterViewInit lifecycle hooks
         * @param {?} diagram
         * @param {?} zone
         * @return {?}
         */
        NgDiagramHelper.makeMouseMoveRunOutsideAngularZone = function (diagram, zone) {
            var _this = this;
            diagram.addEventListener = ( /**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = go__namespace.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    zone.run(( /**
                     * @return {?}
                     */function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
        };
        /**
         * Initialize a given diagram's model with given node / link / model data
         * @param {?} diagram
         * @param {?} nodeDataArray
         * @param {?} linkDataArray
         * @param {?} modelData
         * @return {?}
         */
        NgDiagramHelper.initializeModel = function (diagram, nodeDataArray, linkDataArray, modelData) {
            diagram.delayInitialization(( /**
             * @return {?}
             */function () {
                /** @type {?} */
                var model = diagram.model;
                model.commit(( /**
                 * @param {?} m
                 * @return {?}
                 */function (m) {
                    if (modelData) {
                        m.assignAllDataProperties(m.modelData, modelData);
                    }
                    m.mergeNodeDataArray(m.cloneDeep(nodeDataArray));
                    if (linkDataArray && m instanceof go__namespace.GraphLinksModel) {
                        m.mergeLinkDataArray(m.cloneDeep(linkDataArray));
                    }
                }), null);
            }));
        };
        /**
         * Initialize the model changed listener for the Palette / Diagram of a given compoennt; ensure it runs inside the component's ngZone.
         * Those changes will be emitted through a the component's modelChange EventEmitter.
         * @param {?} component
         * @return {?}
         */
        NgDiagramHelper.initializeModelChangedListener = function (component) {
            /** @type {?} */
            var diagram = null;
            if (!(component.hasOwnProperty("diagram")) && !(component.hasOwnProperty("palette")))
                return;
            if (component.hasOwnProperty("diagram"))
                diagram = component["diagram"];
            if (component.hasOwnProperty("palette"))
                diagram = component["palette"];
            component.modelChangedListener = ( /**
             * @param {?} e
             * @return {?}
             */function (e) {
                if (e.isTransactionFinished && e.model && !e.model.isReadOnly && component.modelChange) {
                    // this must be done within a NgZone.run block, so changes are detected in the parent component
                    component.zone.run(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var dataChanges = ( /** @type {?} */(e.model)).toIncrementalData(e);
                        if (dataChanges !== null)
                            component.modelChange.emit(dataChanges);
                    }));
                }
            });
            diagram.addModelChangedListener(component.modelChangedListener);
        };
        /**
         * Merge the app-level node / link / model data of a supplied Diagram|Palette Component with its underlying Diagram|Palette model data
         * @param {?} component
         * @param {?=} isInit Whether or not to treat this update as a Diagram initialization
         * @return {?}
         */
        NgDiagramHelper.mergeAppDataWithModel = function (component, isInit) {
            /** @type {?} */
            var diagram = null;
            if (component.hasOwnProperty("diagram"))
                diagram = component["diagram"];
            if (component.hasOwnProperty("palette"))
                diagram = component["palette"];
            diagram.model.commit(( /**
             * @param {?} m
             * @return {?}
             */function (m) {
                if (isInit)
                    diagram.model.modelData = {};
                // update modelData first, in case bindings on nodes / links depend on model data
                diagram.model.assignAllDataProperties(diagram.model.modelData, component.modelData);
                // merge node / link data
                if (isInit)
                    diagram.model.nodeDataArray = [];
                diagram.model.mergeNodeDataArray(component.nodeDataArray);
                if (component.linkDataArray && diagram.model instanceof go__namespace.GraphLinksModel) {
                    if (isInit)
                        diagram.model.linkDataArray = [];
                    diagram.model.mergeLinkDataArray(component.linkDataArray);
                }
            }), isInit ? null : 'update data');
        };
        return NgDiagramHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/diagram.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DiagramComponent = /** @class */ (function () {
        /**
         * @param {?} zone
         */
        function DiagramComponent(zone) {
            this.zone = zone;
            /**
             * Link data for diagram. Optional.
             */
            this.linkDataArray = null;
            /**
             * Model data for diagram. Optional.
             */
            this.modelData = null;
            /**
             * Model changed listener function for diagram
             */
            this.modelChangedListener = null;
            /**
             * Whether or not to skip merging app data with GoJS model data (set to true if update is coming from GoJS, false if coming from app-level, usually)
             */
            this.skipsDiagramUpdate = false;
            /**
             * Event emitter -- fires when diagram model changes. Capture this emitted event in parent component
             */
            this.modelChange = new core.EventEmitter();
            /**
             * The Diagram itself
             */
            this.diagram = null;
            /**
             * An internal flag used to tell ngOnChanges to treat the next sync operation as a Diagram initialization
             */
            this.wasCleared = false;
        }
        /**
         * Initializes diagram / model after view init
         * @return {?}
         */
        DiagramComponent.prototype.ngAfterViewInit = function () {
            if (!this.diagramDiv) {
                throw new Error("diagramDiv is not defined");
            }
            this.diagram = this.initDiagram();
            if (!(this.diagram instanceof go__namespace.Diagram)) {
                throw new Error("initDiagram function did not return a go.Diagram");
            }
            // reduces change detection on mouse moves, boosting performance
            NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.diagram, this.zone);
            // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function defined in makeMouseMoveRunOutsideAngularZone
            /** @type {?} */
            var divRef = this.diagramDiv.nativeElement;
            if (divRef === null)
                return;
            this.diagram.div = divRef;
            // initialize the diagram model with the provided node / link / model data
            NgDiagramHelper.initializeModel(this.diagram, this.nodeDataArray, this.linkDataArray, this.modelData);
            // initializer model listener
            NgDiagramHelper.initializeModelChangedListener(this);
        }; // end ngAfterViewInit
        // end ngAfterViewInit
        /**
         * If a change has occurred on an \@Input property, merge the app-level changes with GoJS
         * @return {?}
         */
        DiagramComponent.prototype.ngOnChanges = function () {
            var _this = this;
            if (!this.diagram || !this.diagram.model || this.skipsDiagramUpdate)
                return;
            // if clear was just called, treat this as initial
            if (this.wasCleared) {
                this.diagram.delayInitialization(( /**
                 * @return {?}
                 */function () {
                    NgDiagramHelper.mergeAppDataWithModel(_this, true);
                }));
                this.wasCleared = false;
            }
            else {
                NgDiagramHelper.mergeAppDataWithModel(this);
            }
        }; // end ngOnChanges
        // end ngOnChanges
        /**
         * Clears the diagram of all nodes, links, and model data.
         * Also clears the UndoManager history and clipboard.
         * The next state update will be treated as diagram initialization.
         * @return {?}
         */
        DiagramComponent.prototype.clear = function () {
            /** @type {?} */
            var diagram = this.diagram;
            if (diagram !== null) {
                diagram.clear();
                this.wasCleared = true;
            }
        }; // end clear function
        // end clear function
        /**
         * Set this.diagram.div to null, removing all event listeners
         * @return {?}
         */
        DiagramComponent.prototype.ngOnDestroy = function () {
            this.diagram.div = null; // removes event listeners
        }; // end ngOnDestroy function
        return DiagramComponent;
    }());
    DiagramComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'gojs-diagram',
                    template: '<div #ngDiagram [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    DiagramComponent.ctorParameters = function () { return [
        { type: core.NgZone }
    ]; };
    DiagramComponent.propDecorators = {
        initDiagram: [{ type: core.Input }],
        nodeDataArray: [{ type: core.Input }],
        linkDataArray: [{ type: core.Input }],
        modelData: [{ type: core.Input }],
        divClassName: [{ type: core.Input }],
        skipsDiagramUpdate: [{ type: core.Input }],
        modelChange: [{ type: core.Output }],
        diagramDiv: [{ type: core.ViewChild, args: ['ngDiagram', { static: true },] }]
    };
    if (false) {
        /**
         * Diagram initialization function. Returns a go.Diagram.
         * Do not initialize model data in this function.
         * @type {?}
         */
        DiagramComponent.prototype.initDiagram;
        /**
         * Node data for diagram
         * @type {?}
         */
        DiagramComponent.prototype.nodeDataArray;
        /**
         * Link data for diagram. Optional.
         * @type {?}
         */
        DiagramComponent.prototype.linkDataArray;
        /**
         * Model data for diagram. Optional.
         * @type {?}
         */
        DiagramComponent.prototype.modelData;
        /**
         * Diagram div class name. Use this name to style your diagram in CSS.
         * @type {?}
         */
        DiagramComponent.prototype.divClassName;
        /**
         * Model changed listener function for diagram
         * @type {?}
         */
        DiagramComponent.prototype.modelChangedListener;
        /**
         * Whether or not to skip merging app data with GoJS model data (set to true if update is coming from GoJS, false if coming from app-level, usually)
         * @type {?}
         */
        DiagramComponent.prototype.skipsDiagramUpdate;
        /**
         * Event emitter -- fires when diagram model changes. Capture this emitted event in parent component
         * @type {?}
         */
        DiagramComponent.prototype.modelChange;
        /**
         * The DIV element holding the Diagram
         * @type {?}
         */
        DiagramComponent.prototype.diagramDiv;
        /**
         * The Diagram itself
         * @type {?}
         */
        DiagramComponent.prototype.diagram;
        /**
         * An internal flag used to tell ngOnChanges to treat the next sync operation as a Diagram initialization
         * @type {?}
         * @private
         */
        DiagramComponent.prototype.wasCleared;
        /** @type {?} */
        DiagramComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/palette.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PaletteComponent = /** @class */ (function () {
        /**
         * @param {?} zone
         */
        function PaletteComponent(zone) {
            this.zone = zone;
            /**
             * Link data for palette. Optional.
             */
            this.linkDataArray = null;
            /**
             * Model data for palette. Optional.
             */
            this.modelData = null;
            /**
             * Event emitter -- fires when palette model changes. Capture this emitted event in parent component
             */
            this.modelChange = new core.EventEmitter();
            /**
             * The Palette itself
             */
            this.palette = null;
        }
        /**
         * Initialize Palette after view init
         * @return {?}
         */
        PaletteComponent.prototype.ngAfterViewInit = function () {
            if (!this.paletteDiv) {
                throw new Error("paletteDiv is not defined");
            }
            this.palette = this.initPalette();
            if (!(this.palette instanceof go__namespace.Palette)) {
                throw new Error("initPalette function did not return a go.Palette");
            }
            // reduces change detection on mouse moves, boosting performance
            NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.palette, this.zone);
            // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function above
            /** @type {?} */
            var divRef = this.paletteDiv.nativeElement;
            if (divRef == null)
                return;
            this.palette.div = divRef;
            // initialize palette model
            NgDiagramHelper.initializeModel(this.palette, this.nodeDataArray, this.linkDataArray, this.modelData);
        };
        /**
         * If a change has occured on an \@Input property, merge the app-level changes with GoJS
         * @return {?}
         */
        PaletteComponent.prototype.ngOnChanges = function () {
            if (!this.palette || !this.palette.model)
                return;
            NgDiagramHelper.mergeAppDataWithModel(this);
        }; // end ngOnChanges 
        // end ngOnChanges 
        /**
         * @return {?}
         */
        PaletteComponent.prototype.ngOnDestroy = function () {
            this.palette.div = null; // removes event listeners
        };
        return PaletteComponent;
    }());
    PaletteComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'gojs-palette',
                    template: '<div #ngPalette [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    PaletteComponent.ctorParameters = function () { return [
        { type: core.NgZone }
    ]; };
    PaletteComponent.propDecorators = {
        initPalette: [{ type: core.Input }],
        nodeDataArray: [{ type: core.Input }],
        linkDataArray: [{ type: core.Input }],
        modelData: [{ type: core.Input }],
        divClassName: [{ type: core.Input }],
        modelChange: [{ type: core.Output }],
        paletteDiv: [{ type: core.ViewChild, args: ['ngPalette', { static: true },] }]
    };
    if (false) {
        /**
         * Palette initialization function. Returns a go.Palette.
         * Do not initialize model data in this function.
         * @type {?}
         */
        PaletteComponent.prototype.initPalette;
        /**
         * Node data for palette
         * @type {?}
         */
        PaletteComponent.prototype.nodeDataArray;
        /**
         * Link data for palette. Optional.
         * @type {?}
         */
        PaletteComponent.prototype.linkDataArray;
        /**
         * Model data for palette. Optional.
         * @type {?}
         */
        PaletteComponent.prototype.modelData;
        /**
         * Palette div class name. Use this name to style your palette in CSS
         * @type {?}
         */
        PaletteComponent.prototype.divClassName;
        /**
         * Event emitter -- fires when palette model changes. Capture this emitted event in parent component
         * @type {?}
         */
        PaletteComponent.prototype.modelChange;
        /**
         * The DIV element holding the Palette
         * @type {?}
         */
        PaletteComponent.prototype.paletteDiv;
        /**
         * The Palette itself
         * @type {?}
         */
        PaletteComponent.prototype.palette;
        /** @type {?} */
        PaletteComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/overview.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OverviewComponent = /** @class */ (function () {
        /**
         * @param {?} zone
         */
        function OverviewComponent(zone) {
            this.zone = zone;
            /**
             * The Diagram to observe with the Overview
             */
            this.observedDiagram = null;
            /**
             * The Overview itself
             */
            this.overview = null;
        }
        /**
         * Initialize the overview
         * @return {?}
         */
        OverviewComponent.prototype.ngAfterViewInit = function () {
            if (!this.overviewDiv) {
                throw new Error("overviewDiv is not defined");
            }
            if (this.initOverview) {
                this.overview = this.initOverview();
                if (!(this.overview instanceof go__namespace.Overview)) {
                    throw new Error("initOverview function did not return a go.Overview");
                }
            }
            else {
                this.overview = new go__namespace.Overview();
                this.overview.contentAlignment = go__namespace.Spot.Center;
            }
            // reduces change detection on mouse moves, boosting performance
            NgDiagramHelper.makeMouseMoveRunOutsideAngularZone(this.overview, this.zone);
            this.overview.div = this.overviewDiv.nativeElement;
        };
        /**
         * Only update when the observed diagram changes
         * @param {?} changes
         * @return {?}
         */
        OverviewComponent.prototype.ngOnChanges = function (changes) {
            if (!this.overview)
                return;
            if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {
                this.overview.observed = changes.observedDiagram.currentValue;
            }
        };
        /**
         * @return {?}
         */
        OverviewComponent.prototype.ngOnDestroy = function () {
            this.overview.div = null; // removes event listeners
        };
        return OverviewComponent;
    }());
    OverviewComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'gojs-overview',
                    template: '<div #ngOverview [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    OverviewComponent.ctorParameters = function () { return [
        { type: core.NgZone }
    ]; };
    OverviewComponent.propDecorators = {
        initOverview: [{ type: core.Input }],
        divClassName: [{ type: core.Input }],
        observedDiagram: [{ type: core.Input }],
        overviewDiv: [{ type: core.ViewChild, args: ['ngOverview', { static: true },] }]
    };
    if (false) {
        /**
         * The function used to initialize and return the Overview
         * @type {?}
         */
        OverviewComponent.prototype.initOverview;
        /**
         * The div class name that holds the Overview. Use this name to style your Overview in CSS.
         * @type {?}
         */
        OverviewComponent.prototype.divClassName;
        /**
         * The Diagram to observe with the Overview
         * @type {?}
         */
        OverviewComponent.prototype.observedDiagram;
        /** @type {?} */
        OverviewComponent.prototype.overviewDiv;
        /**
         * The Overview itself
         * @type {?}
         */
        OverviewComponent.prototype.overview;
        /** @type {?} */
        OverviewComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/data-sync.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSyncService = /** @class */ (function () {
        function DataSyncService() {
        }
        /**
         * Sync a node data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} nodeData The node data array to merge these changes with
         * @param {?=} model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
         * @return {?} A node data array, merged with the changes
         */
        DataSyncService.syncNodeData = function (changes, nodeData, model) {
            if (!changes)
                return nodeData;
            if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
                return nodeData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedNodesMap = new go__namespace.Map();
            // nodeData is immutable, modify it using the immer package's "produce" function (creates new array)
            /** @type {?} */
            var newNodeDataArray = produce__default['default'](nodeData, ( /**
             * @param {?} draft
             * @return {?}
             */function (draft) {
                // account for modified node data
                if (changes.modifiedNodeData) {
                    changes.modifiedNodeData.forEach(( /**
                     * @param {?} nd
                     * @return {?}
                     */function (nd) {
                        // Get the value of the node key property checking wether is a function or a string
                        /** @type {?} */
                        var key = model ? model.getKeyForNodeData(nd) : nd['key'];
                        modifiedNodesMap.set(key, nd);
                        for (var i = 0; i < nodeData.length; i++) {
                            /** @type {?} */
                            var ndEntry = nodeData[i];
                            /** @type {?} */
                            var keyNdEntry = model ? model.getKeyForNodeData(ndEntry) : ndEntry['key'];
                            if (keyNdEntry === key) {
                                draft[i] = nd;
                            }
                        }
                    }));
                }
                // account for inserted node data
                if (changes.insertedNodeKeys) {
                    changes.insertedNodeKeys.forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (key) {
                        /** @type {?} */
                        var nd = modifiedNodesMap.get(key);
                        if (nd) {
                            draft.push(nd);
                        }
                    }));
                }
                // account for removed node data
                if (changes.removedNodeKeys) {
                    return draft.filter(( /**
                     * @param {?} nd
                     * @return {?}
                     */function (nd) {
                        /** @type {?} */
                        var key = model ? model.getKeyForNodeData(nd) : nd['key'];
                        if (changes.removedNodeKeys.includes(key)) {
                            return false;
                        }
                        return true;
                    }));
                }
            }));
            return newNodeDataArray;
        };
        /**
         * Sync a link data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} linkData The link data array to merge these changes with
         * @param {?=} model Required if you have defined your model.linkKeyProperty to be something other than 'key'
         * @return {?} A link data array, merged with the changes
         */
        DataSyncService.syncLinkData = function (changes, linkData, model) {
            if (!changes)
                return linkData;
            if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
                return linkData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedLinksMap = new go__namespace.Map();
            // linkData is immutable, modify it using the immer package's "produce" function (creates new array)
            linkData = produce__default['default'](linkData, ( /**
             * @param {?} draft
             * @return {?}
             */function (/**
             * @param {?} draft
             * @return {?}
             */ draft) {
                // account for modified link data
                if (changes.modifiedLinkData) {
                    changes.modifiedLinkData.forEach(( /**
                     * @param {?} ld
                     * @return {?}
                     */function (ld) {
                        // Get the value of the link key
                        /** @type {?} */
                        var key = model ? model.getKeyForLinkData(ld) : ld['key'];
                        modifiedLinksMap.set(key, ld);
                        for (var i = 0; i < linkData.length; i++) {
                            /** @type {?} */
                            var ldEntry = linkData[i];
                            /** @type {?} */
                            var keyLdEntry = model ? model.getKeyForLinkData(ldEntry) : ldEntry['key'];
                            if (keyLdEntry === key) {
                                draft[i] = ld;
                            }
                        }
                    }));
                }
                // account for inserted link data
                if (changes.insertedLinkKeys) {
                    changes.insertedLinkKeys.forEach(( /**
                     * @param {?} key
                     * @return {?}
                     */function (key) {
                        /** @type {?} */
                        var nd = modifiedLinksMap.get(key);
                        if (nd) {
                            draft.push(nd);
                        }
                    }));
                }
                // account for removed link data
                if (changes.removedLinkKeys) {
                    return draft.filter(( /**
                     * @param {?} ld
                     * @return {?}
                     */function (ld) {
                        /** @type {?} */
                        var key = model ? model.getKeyForLinkData(ld) : ld['key'];
                        if (changes.removedLinkKeys.includes(key)) {
                            return false;
                        }
                        return true;
                    }));
                }
            }));
            return linkData;
        };
        /**
         * Sync modelData with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} modelData The modelData to merge these changes with
         * @return {?} A modelData object, merged with the changes
         */
        DataSyncService.syncModelData = function (changes, modelData) {
            if (!changes)
                return modelData;
            if (!changes.modelData)
                return modelData;
            if (changes.modelData) {
                return changes.modelData;
            }
        };
        return DataSyncService;
    }());
    DataSyncService.decorators = [
        { type: core.Injectable }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/gojs-angular.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GojsAngularModule = /** @class */ (function () {
        function GojsAngularModule() {
        }
        return GojsAngularModule;
    }());
    GojsAngularModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        DiagramComponent,
                        OverviewComponent,
                        PaletteComponent
                    ],
                    imports: [],
                    providers: [
                        DataSyncService
                    ],
                    exports: [
                        DiagramComponent,
                        OverviewComponent,
                        PaletteComponent
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: gojs-angular.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.DataSyncService = DataSyncService;
    exports.DiagramComponent = DiagramComponent;
    exports.GojsAngularModule = GojsAngularModule;
    exports.OverviewComponent = OverviewComponent;
    exports.PaletteComponent = PaletteComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=gojs-angular.umd.js.map
